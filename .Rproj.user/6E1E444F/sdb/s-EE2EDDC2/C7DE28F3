{
    "collab_server" : "",
    "contents" : "\n#------------------------------------------------\n# Get alpha and beta parameters of inverse-gamma prior on sigma^2 from expectation and variance.\n# (not exported)\n\nget_alpha_beta <- function(sigma_mean,sigma_var) {\n  \n  # define a function that has minimum at correct value of alpha\n  f_alpha <- function(alpha) {\n    (sqrt((sigma_var+sigma_mean^2)*(alpha-1))*exp(lgamma(alpha-0.5)-lgamma(alpha))-sigma_mean)^2\n  }\n  \n  # search for alpha\n  alpha <- optim(2,f_alpha,method='Brent',lower=1,upper=1e3)$par\n  \n  # solve for beta\n  beta <- (sigma_var+sigma_mean^2)*(alpha-1)\n  \n  # check that chosen alpha is not at limit of range\n  if (alpha>(1e3-1))\n    stop('unable to define prior on sigma for chosen values of sigma_mean and sigma_var. Try increasing the value of sigma_var, or alternatively setting sigma_var=0 (i.e. using fixed-sigma model)')\n  \n  output <- list(alpha=alpha, beta=beta)\n  return(output)\n}\n\n#------------------------------------------------\n#' Convert lat-lon to bearing\n#'\n#' Calculate bearing and great circle distance between an origin and one or more destination points\n#'\n#' @param origin_lat latitude of origin point\n#' @param origin_lon longitude of origin point\n#' @param dest_lat latitude of destination point\n#' @param dest_lon longitude of destination point\n\nlatlon_to_bearing <- function(origin_lat, origin_lon, dest_lat, dest_lon) {\n  \n  # convert input arguments to radians\t\n  origin_lat <- origin_lat*2*pi/360\n  dest_lat <- dest_lat*2*pi/360\n  origin_lon <- origin_lon*2*pi/360\n  dest_lon <- dest_lon*2*pi/360\n  \n  delta_lon <- dest_lon-origin_lon\n  \n  # calculate bearing and great circle distance\n  bearing <- atan2(sin(delta_lon)*cos(dest_lat), cos(origin_lat)*sin(dest_lat)-sin(origin_lat)*cos(dest_lat)*cos(delta_lon))\n  gc_angle <- acos(sin(origin_lat)*sin(dest_lat) + cos(origin_lat)*cos(dest_lat)*cos(delta_lon))\n  \n  # convert bearing from radians to degrees measured clockwise from due north, and convert gc_angle to great circle distance via radius of earth (km)\n  bearing <- bearing*360/(2*pi)\n  bearing <- (bearing+360)%%360\n  earthRad <- 6371\n  gc_dist <- earthRad*gc_angle\n  \n  return(list(bearing=bearing, gc_dist=gc_dist))\n}\n\n#------------------------------------------------\n# Convert lat/lon coordinates to cartesian coordinates by first calculating great circle distance and bearing and then mapping these coordinates into cartesian space. This mapping is relative to the point {centre_lat, centre_lon}, which should be roughly at the midpoint of the observed data.\n# (not exported)\n\nlatlon_to_cartesian <- function(centre_lat, centre_lon, data_lat, data_lon) {\n  \n  # calculate bearing and great circle distance of data relative to centre\n  data_trans <- latlon_to_bearing(centre_lat, centre_lon, data_lat, data_lon)\n  \n  # use bearing and distance to calculate cartesian coordinates\n  theta <- data_trans$bearing*2*pi/360\n  d <- data_trans$gc_dist\n  data_x <- d*sin(theta)\n  data_y <- d*cos(theta)\n  \n  return(list(x=data_x, y=data_y))\n}\n\n#------------------------------------------------\n# Calculate destination lat/lon given an origin, a bearing and a great circle distance of travel\n# Note that bearing should be in degrees relative to due north, and gc_dist should be in units of kilometres\n# (not exported)\n\nbearing_to_latlon <- function(origin_lat, origin_lon, bearing, gc_dist) {\n  \n  # convert origin_lat, origin_lon and bearing from degrees to radians\n  origin_lat <- origin_lat*2*pi/360\n  origin_lon <- origin_lon*2*pi/360\n  bearing <- bearing*2*pi/360\n  \n  # calculate new lat/lon using great circle distance\n  earthRad <- 6371\n  new_lat <- asin(sin(origin_lat)*cos(gc_dist/earthRad) + cos(origin_lat)*sin(gc_dist/earthRad)*cos(bearing))\n  new_lon <- origin_lon + atan2(sin(bearing)*sin(gc_dist/earthRad)*cos(origin_lat), cos(gc_dist/earthRad)-sin(origin_lat)*sin(new_lat))\n  \n  # convert new_lat and new_lon from radians to degrees\n  new_lat <- new_lat*360/(2*pi)\n  new_lon <- new_lon*360/(2*pi)\n  \n  return(list(longitude=new_lon, latitude=new_lat))\n}\n\n#------------------------------------------------\n# Convert cartesian coordinates to lat/lon by using angle and euclidian distance from origin to define a bearing and great-circle distance relative to some centre point.\n# (not exported)\n\ncartesian_to_latlon <- function(centre_lat, centre_lon, data_x, data_y) {\n  \n  # calculate angle and euclidian distance of all points relative to origin\n  d <- sqrt(data_x^2+data_y^2)\n  theta <- atan2(data_y,data_x)\n  \n  # convert theta to bearing relative to due north\n  theta <- theta*360/(2*pi)\n  theta <- (90-theta)%%360\n  \n  # use bearing and great circle distance to calculate lat/lon relative to an origin point\n  data_trans <- bearing_to_latlon(centre_lat, centre_lon, theta, d)\n  \n  return(list(longitude=data_trans$longitude, latitude=data_trans$latitude))\n}\n\n#------------------------------------------------\n# Square-root-inverse-gamma distribution\n# If an inverse gamma distribution has shape alpha and rate beta, and hence mean beta/(alpha-1) and variance beta^2/((alpha-1)^2*(alpha-2)), then the square root of this random variable has mean epsilon=sqrt(beta)*gamma(alpha-0.5)/gamma(alpha) and variance v=beta/(alpha-1)-epsilon^2. The variance can also be written purely in terms of alpha and epsilon as follows: v=epsilon^2*(gamma(alpha-1)*gamma(alpha)/gamma(alpha-0.5)^2 - 1).\n# (not exported)\n\ndRIG <- function(x,alpha,beta,log=FALSE) {\n  output <- log(2)+alpha*log(beta)-lgamma(alpha)-(2*alpha+1)*log(x)-beta/x^2\n  if (!log)\n    output <- exp(output)\n  return(output)\n}\n\n#------------------------------------------------\n# Scaled Student's t distribution. Used in kernel density smoothing.\n# (not exported)\n\ndts <- function(x, df, scale=1, log=FALSE) {\n  ret <- lgamma((df+1)/2)-lgamma(df/2)-0.5*log(pi*df*scale^2) - ((df+1)/2)*log(1 + x^2/(df*scale^2))\n  if (!log) { ret <- exp(ret) }\n  return(ret)\n}\n\n#------------------------------------------------\n#' Draw from Dirichlet process mixture model\n#'\n#' Provides random draws from a 2D spatial Dirichlet process mixture model. Both sigma and tau are defined in units of kilometres, representing the average distance that an observations lies from a source, and the average distance that a source lies from the centre point respectively. In contrast, the location of the centre point and the locations of the final output crime sites are defined in units of degrees lat/long to facilitate spatial analysis.\n#'\n#' Output includes the lat/long locations of the points drawn from the DPM model, along with the underlying group allocation (i.e. which points belong to which sources) and the lat/long locations of the sources.\n#'\n#' @param n number of draws.\n#' @param sigma standard deviation of dispersal distribution, in units of kilometres.\n#' @param tau standard deviation of prior on source locations (i.e. average distances of sources from centre point), in units of kilometres.\n#' @param priorMean_longitude location of prior mean on source locations in degrees longitude.\n#' @param priorMean_latitude location of prior mean on source locations in degrees latitude.\n#' @param alpha concentration parameter of Dirichlet process model. Large alpha implies many distinct sources, while small alpha implies only a few sources.\n#'\n#' @export\n#' @examples\n#' # produces clusters of points from sources centred on QMUL\n#' rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = 51.5235505, \n#' alpha=1, sigma=1, tau=3) \n#' # same, but increasing alpha to generate more clusters\n#' rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = 51.5235505, \n#' alpha=5, sigma=1, tau=3)\n\nrDPM <- function(n, sigma=1, tau=10, priorMean_longitude=-0.1277, priorMean_latitude=51.5074, alpha=1) {\n  \n  # force n to be a scalar integer\n  n <- floor(n[1])\n  \n  # draw grouping\n  group <- rep(1,n)\n  freqs <- 1\n  if (n>1) {\n    for (i in 2:n) {\n      group[i] <- sample(length(freqs)+1,1,prob=c(freqs,alpha))\n      if (group[i]>length(freqs))\n        freqs <- c(freqs,0)\n      freqs[group[i]] <- freqs[group[i]] + 1\n    }\n  }\n  group <- sort(group)\n  \n  # draw source locations\n  source <- rnorm_sphere(length(freqs), priorMean_latitude, priorMean_longitude, tau)\n  \n  # draw crime locations from sources\n  crime <- rnorm_sphere(n, source$latitude[group], source$longitude[group], sigma)\n  \n  # return results\n  return(list(longitude=crime$longitude, latitude=crime$latitude, group=group, source_lon=source$longitude, source_lat=source$latitude))\n}\n\n#------------------------------------------------\n# Draw from normal distribution converted to spherical coordinate system. Points are first drawn from an ordinary cartesian 2D normal distribution. The distances to points are then assumed to be great circle distances, and are combined with a random bearing from the point {centre_lat, centre_lon} to produce a final set of lat/lon points. Note that this is not a truly spherical normal distribution, as the domain of the distribution is not the sphere - rather it is a transformation from one coordinate system to another that is satisfactory when the curvature of the sphere is not severe.\n# (not exported)\n\nrnorm_sphere <- function(n, centre_lat, centre_lon, sigma) {\n  x <- rnorm(n,sd=sigma)\n  y <- rnorm(n,sd=sigma)\n  output <- cartesian_to_latlon(centre_lat, centre_lon, x, y)\n  return(output)\n}\n\n#------------------------------------------------\n# Bin values in two dimensions\n# (not exported)\n\nbin2D <- function(x, y, x_breaks, y_breaks) {\n  \n  # get number of breaks in each dimension\n  nx <- length(x_breaks)\n  ny <- length(y_breaks)\n  \n  # create table of binned values\n  tab1 <- table(findInterval(x, x_breaks), findInterval(y, y_breaks))\n  \n  # convert to dataframe and force numeric\n  df1 <- as.data.frame(tab1, stringsAsFactors=FALSE)\n  names(df1) <- c(\"x\", \"y\", \"count\")\n  df1$x <- as.numeric(df1$x)\n  df1$y <- as.numeric(df1$y)\n  \n  # subset to within breaks range\n  df2 <- subset(df1, x>0 & x<nx & y>0 & y<ny)\n  \n  # fill in matrix\n  mat1 <- matrix(0,ny-1,nx-1)\n  mat1[cbind(df2$y, df2$x)] <- df2$count\n  \n  # calculate cell midpoints\n  x_mids <- (x_breaks[-1]+x_breaks[-nx])/2\n  y_mids <- (y_breaks[-1]+y_breaks[-ny])/2\n  \n  # return output as list\n  output <- list(x_mids=x_mids, y_mids=y_mids, z=mat1)\n  return(output)\n}\n\n#------------------------------------------------\n#' Produce a smooth surface using 2D kernel density smoothing\n#'\n#' Takes lon/lat coordinates, bins in two dimensions, and smooths using kernel density smoothing. Kernel densities are computed using the fast Fourier transform method, which is many times faster than simple summation when using a large number of points. Each Kernel is student's-t distributed with 3 degrees of freedom, and scaled by the bandwidth lambda. If lambda is set to \\code{NULL} then the optimal value of lambda is chosen automatically using the leave-one-out maximum likelihood method.\n#'\n#' @param longitude longitude of input points\n#' @param latitude latitude of input points\n#' @param breaks_lon positions of longitude breaks\n#' @param breaks_lat positions of latitude breaks\n#' @param lambda bandwidth to use in posterior smoothing. If NULL then optimal bandwidth is chosen automatically by maximum-likelihood.\n#'\n#' @references Barnard, Etienne. \"Maximum leave-one-out likelihood for kernel density estimation.\" Proceedings of the Twenty-First Annual Symposium of the Pattern Recognition Association of South Africa. 2010.\n#' @export\n#' @examples\n#' # create smooth surface based on raw LondonExample_crimes\n#' breaks_lon <- seq(-0.25,0.05,l=101)\n#' breaks_lat <- seq(51.45,51.6,l=101)\n#' m <- geoSmooth(LondonExample_crimes$longitude, LondonExample_crimes$latitude,\n#'                  breaks_lon, breaks_lat)\n#' \n#' # produce image plot of surface and overlay points\n#' image(breaks_lon, breaks_lat, t(m), xlab=\"longitude\", ylab=\"latitude\")\n#' points(LondonExample_crimes$longitude, LondonExample_crimes$latitude)\n\ngeoSmooth <- function(longitude, latitude, breaks_lon, breaks_lat, lambda=NULL) {\n  \n  # get properties of cells in each dimension\n  cells_lon <- length(breaks_lon) - 1\n  cells_lat <- length(breaks_lat) - 1\n  centre_lon <- mean(breaks_lon)\n  centre_lat <- mean(breaks_lat)\n  cellSize_lon <- diff(breaks_lon[1:2])\n  cellSize_lat <- diff(breaks_lat[1:2])\n  \n  # bin lon/lat values in two dimensions and check that at least one value in chosen region\n  surface_raw <- bin2D(longitude, latitude, breaks_lon, breaks_lat)$z\n  if (all(surface_raw==0)) { stop('chosen lat/long window contains no posterior draws') }\n  \n  # temporarily add guard rail to surface to avoid Fourier series bleeding round edges\n  railSize_lon <- cells_lon\n  railSize_lat <- cells_lat\n  railMat_lon <- matrix(0, cells_lat, railSize_lon)\n  railMat_lat <- matrix(0, railSize_lat, cells_lon + 2*railSize_lon)\n  \n  surface_normalised <- surface_raw/sum(surface_raw)\n  surface_normalised <- cbind(railMat_lon, surface_normalised, railMat_lon)\n  surface_normalised <- rbind(railMat_lat, surface_normalised, railMat_lat)\n  \n  # calculate Fourier transform of posterior surface\n  f1 = fftw2d(surface_normalised)\n  \n  # calculate x and y size of one cell in cartesian space. Because of transformation, this size will technically be different for each cell, but use centre of space to get a middling value\n  cellSize_trans <- latlon_to_cartesian(centre_lat, centre_lon, centre_lat + cellSize_lat, centre_lon + cellSize_lon)\n  cellSize_trans_lon <- cellSize_trans$x\n  cellSize_trans_lat <- cellSize_trans$y\n  \n  # produce surface over which kernel will be calculated. This surface wraps around in both x and y (i.e. the kernel is actually defined over a torus).\n  kernel_lon <- cellSize_trans_lon * c(0:floor(ncol(surface_normalised)/2), floor((ncol(surface_normalised) - 1)/2):1)\n  kernel_lat <- cellSize_trans_lat * c(0:floor(nrow(surface_normalised)/2), floor((nrow(surface_normalised) - 1)/2):1)\n  kernel_lon_mat <- outer(rep(1,length(kernel_lat)), kernel_lon)\n  kernel_lat_mat <- outer(kernel_lat, rep(1,length(kernel_lon)))\n  kernel_s_mat <- sqrt(kernel_lon_mat^2 + kernel_lat_mat^2)\n  \n  # set lambda (bandwidth) range to be explored\n  if (is.null(lambda)) {\n    lambda_step <- min(cellSize_trans_lon, cellSize_trans_lat)/5\n    lambda_vec <- lambda_step*(1:100)\n  } else {\n    lambda_vec <- lambda\n  }\n  \n  # loop through range of values of lambda\n  cat('Smoothing posterior surface')\n  flush.console()\n  logLike <- -Inf\n  for (i in 1:length(lambda_vec)) {\n    \n    # print dots to screen\n    if (i>1) {\n      cat(\".\")\n      flush.console()\n    }\n    \n    # calculate Fourier transform of kernel\n    lambda_this <- lambda_vec[i]\n    kernel <- dts(kernel_s_mat, df=3, scale=lambda_this)\n    f2 = fftw2d(kernel)\n    \n    # combine Fourier transformed surfaces and take inverse. f4 will ultimately become the main surface of interest.\n    f3 = f1*f2\n    f4 = Re(fftw2d(f3,inverse=T))/length(surface_normalised)\n    \n    # subtract from f4 the probability density of each point measured from itself. In other words, move towards a leave-one-out kernel density method\n    f5 <- f4 - surface_normalised*dts(0, df=3, scale=lambda_this)\n    f5[f5<0] <- 0\n    f5 <- f5/sum(f4)\n    \n    # calculate leave-one-out log-likelihood at each point on surface\n    f6 <- surface_normalised*log(f5)\n    \n    # break if total log-likelihood is at a local maximum\n    if (sum(f6,na.rm=T)<logLike) { break() }\n    \n    # otherwise update logLike\n    logLike <- sum(f6,na.rm=T)\n  }\n  \n  # report chosen value of lambda\n  if (is.null(lambda)) {\n    cat(paste('\\nmaximum likelihood lambda = ', round(lambda_this,3), sep=''))\n  }\n  \n  # remove guard rail\n  f4 <- f4[,(railSize_lon+1):(ncol(f4)-railSize_lon)]\n  f4 <- f4[(railSize_lat+1):(nrow(f4)-railSize_lat),]\n  \n  # return surface\n  return(f4)\n}\n",
    "created" : 1523612911586.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1497681282",
    "id" : "C7DE28F3",
    "lastKnownWriteTime" : 1523614353,
    "last_content_update" : 1523614353961,
    "path" : "~/Dropbox/Bob/Work/My Programs/Geoprofiling/RgeoProfile/R/misc.R",
    "project_path" : "R/misc.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}