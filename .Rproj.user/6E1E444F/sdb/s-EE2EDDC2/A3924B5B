{
    "collab_server" : "",
    "contents" : "\n#------------------------------------------------\n# The following commands are needed to ensure that the roxygen2 package, which deals with documenting the package, does not conflict with the Rcpp package.\n\n# Rcpp          - allows C++ integration\n# fftwtools     - fast Fourier transform, used when smoothing posterior draws into final surface\n# ggplot2       - used to produce layered plots\n# ggmap         - needed for the get_map function, although ggmap function itself is broken\n# RColorBrewer  - used to define default colours in geoPlotAllocation\n# rgdal         - required to load shapefiles\n# raster        - required when using masks\n# viridis       - colour palettes\n# ...           - other importFrom declarations recommended by devtools::check\n\n#' @useDynLib RgeoProfile\n#' @importFrom Rcpp evalCpp\n#' @import fftwtools\n#' @import ggplot2\n#' @import ggmap\n#' @import RColorBrewer\n#' @import rgdal\n#' @importFrom raster raster extent extent<- rasterize projectRaster distance\n#' @import viridis\n#' @importFrom grDevices colorRampPalette\n#' @import graphics\n#' @import stats\n#' @import utils\nNULL\n\n#------------------------------------------------\n#' Create Rgeoprofile data object\n#'\n#' Simple function that ensures that input data is in the correct format required by Rgeoprofile. Takes longitude and latitude as input vectors and returns these same values in list format.\n#'\n#' @param longitude the locations of the observed data in degrees longitude.\n#' @param latitude the locations of the observed data in degrees latitude.\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' geoData(Cholera$longitude, Cholera$latitude)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' geoData(sim$longitude, sim $latitude)\n\ngeoData <- function(longitude=NULL, latitude=NULL) {\n  \n  # check input format\n  stopifnot(!is.null(longitude))\n  stopifnot(!is.null(latitude))\n  stopifnot(length(longitude)==length(latitude))\n  \n  # combine and return\n  ret <- list(longitude=longitude, latitude=latitude)\n  return(ret)\n}\n\n#------------------------------------------------\n#' Create sources data object in same format as observations\n#'\n#' Simple function that ensures that sources are in the correct format required by Rgeoprofile. Takes longitude and latitude as input vectors and returns these same values in list format. If no values are input then default values are used.\n#'\n#' @param longitude the locations of the potential sources in degrees longitude.\n#' @param latitude the locations of the potential sources in degrees latitude.\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' geoDataSource(WaterPumps$longitude, WaterPumps$latitude)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' geoDataSource(sim$longitude, sim$latitude)\n\ngeoDataSource <- function(longitude=NULL, latitude=NULL) {\n  \n  # check input format\n  stopifnot(!is.null(longitude))\n  stopifnot(!is.null(latitude))\n  stopifnot(length(longitude)==length(latitude))\n  \n  # combine and return\n  ret <- list(longitude=longitude, latitude=latitude)\n  return(ret)\n}\n\n#------------------------------------------------\n#' Create Rgeoprofile parameters object\n#'\n#' This function can be used to generate parameters in the format required by other Rgeoprofile functions. Parameter values can be specified as input arguments to this function, or alternatively if data is input as an argument then some parameters can take default values directly from the data.\n#'\n#' @param data observations in the format defined by geoData().\n#' @param sources observations in the format defined by geoDataSource().\n#' @param sigma_mean the mean of the prior on sigma (sigma = standard deviation of the dispersal distribution) in km.\n#' @param sigma_var the variance of the prior on sigma in km^2.\n#' @param sigma_squared_shape as an alternative to defining the prior mean and variance of sigma, it is possible to directly define the parameters of the inverse-gamma prior on sigma^2. If so, this is the shape parameter of the inverse-gamma prior.\n#' @param sigma_squared_rate the rate parameter of the inverse-gamma prior on sigma^2.\n#' @param priorMean_longitude the mean longitude of the normal prior on source locations (in degrees). If NULL then defaults to the midpoint of the range of the data, or -0.1277 if no data provided.\n#' @param priorMean_latitude the mean latitude of the normal prior on source locations (in degrees). If NULL then defaults to the midpoint of the range of the data, or 51.5074 if no data provided.\n#' @param tau the standard deviation of the normal prior on source locations, i.e. how far we expect sources to lie from the centre. If NULL then defaults to the maximum distance of any observation from the prior mean, or 10.0 if no data provided.\n#' @param alpha_shape shape parameter of the gamma prior on the parameter alpha.\n#' @param alpha_rate rate parameter of the gamma prior on the parameter alpha.\n#' @param chains number of MCMC chains to use in the burn-in step.\n#' @param burnin number of burn-in iterations to be discarded at start of MCMC.\n#' @param samples number of sampling iterations. These iterations are used to generate final posterior distribution.\n#' @param burnin_printConsole how frequently (in iterations) to report progress to the console during the burn-in phase.\n#' @param samples_printConsole how frequently (in iterations) to report progress to the console during the sampling phase.\n#' @param longitude_minMax vector containing minimum and maximum longitude over which to generate geoprofile. If NULL then defaults to the range of the data plus a guard rail on either side, or c(-0.1377,-0.1177) if no data provided.\n#' @param latitude_minMax vector containing minimum and maximum latitude over which to generate geoprofile. If NULL then defaults to the range of the data plus a guard rail on either side, or c(51.4974, 51.5174) if no data provided.\n#' @param longitude_cells number of cells in the final geoprofile (longitude direction). Higher values generate smoother distributions, but take longer to run.\n#' @param latitude_cells number of cells in the final geoprofile (latitude direction). Higher values generate smoother distributions, but take longer to run.\n#' @param guardRail when data input is used, longitude_minMax and latitude_minMax default to the range of the data plus a guard rail. This parameter defines the size of the guard rail as a proportion of the range. For example, a value of 0.05 would give an extra 5 percent on the range of the data.\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' # define parameters such that the model fits sigma from the data\n#' geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2, \n#' chains = 10, burnin = 1000, samples = 10000, guardRail = 0.1)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' # use a fixed value of sigma\n#' geoParams(data = d, sigma_mean = 1.0, sigma_var = 0,\n#' chains=10, burnin=1000, samples = 10000, guardRail = 0.1)\n\ngeoParams <- function(data=NULL, sources=NULL, sigma_mean=1, sigma_var=NULL, sigma_squared_shape=NULL, sigma_squared_rate=NULL, priorMean_longitude=NULL, priorMean_latitude=NULL, tau=NULL, alpha_shape=0.1, alpha_rate=0.1, chains=10, burnin=1e3, samples=1e4, burnin_printConsole=100, samples_printConsole=1000, longitude_minMax=NULL, latitude_minMax=NULL, longitude_cells=500, latitude_cells=500, guardRail=0.05) {\n  \n  # if data or sources arguments used then get defaults from these values\n  if (!is.null(data) | !is.null(sources)) {\n    \n    # check correct format of data\n    geoDataCheck(data, silent=TRUE)\n    \n    # if prior mean not defined then set as midpoint of data (if present), otherwise midpoint of sources\n    if (is.null(priorMean_longitude)) {\n      if (is.null(data)) {\n        priorMean_longitude <- sum(range(sources$longitude))/2\n      } else {\n        priorMean_longitude <- sum(range(data$longitude))/2\n      }\n    }\n    if (is.null(priorMean_latitude)) {\n      if (is.null(data)) {\n        priorMean_latitude <- sum(range(sources$latitude))/2\n      } else {\n        priorMean_latitude <- sum(range(data$latitude))/2\n      }\n    }\n    \n    # convert data to bearing and great circle distance, and extract maximum great circle distance to any point. Use maximum distance as default value of tau\n    if (!is.null(data) & is.null(tau)) {\n      data_trans <- latlon_to_bearing(priorMean_latitude, priorMean_longitude, data$latitude, data$longitude)\n      tau <- max(data_trans$gc_dist)\n    }\n    \n    # combine data and sources into single object for convenience\n    data_sources <- list(longitude = c(data$longitude, sources$longitude), latitude = c(data$latitude, sources$latitude))\n    \n    # set map limits based on data, sources, or both\n    if (is.null(longitude_minMax)) {\n      lon_range <- diff(range(data_sources$longitude))\n      lon_min <- min(data_sources$longitude) - guardRail*lon_range\n      lon_max <- max(data_sources$longitude) + guardRail*lon_range\n      longitude_minMax <- c(lon_min, lon_max)\n    }\n    if (is.null(latitude_minMax)) {\n      lat_range <- diff(range(data_sources$latitude))\n      lat_min <- min(data_sources$latitude) - guardRail*lat_range\n      lat_max <- max(data_sources$latitude) + guardRail*lat_range\n      latitude_minMax <- c(lat_min, lat_max)\n    }\n  }\n  \n  # if data and sources arguments not used then set defaults manually\n  if (is.null(data) & is.null(sources)) {\n    if (is.null(priorMean_longitude)) {\n      priorMean_longitude <- -0.1277\n    }\n    if (is.null(priorMean_latitude)) {\n      priorMean_latitude <- 51.5074\n    }\n    if (is.null(longitude_minMax)) {\n      longitude_minMax <- priorMean_longitude + c(-0.01,0.01)\n    }\n    if (is.null(latitude_minMax)) {\n      latitude_minMax <- priorMean_latitude + c(-0.01,0.01)\n    }\n    if (is.null(tau)) {\n      tau <- 10\n    }\n  }\n  \n  # initialise shape and rate parameters for prior on sigma^2\n  alpha <- NULL\n  beta <- NULL\n  \n  # calculate shape and rate parameters of prior on sigma-squared (ie. alpha and beta) from input arguments. The user has several options:\n  #   1) specify sigma_mean and sigma_var, in which case alpha and beta are calculated from these values\n  #   2) specify sigma_mean but not sigma_var, in which case alpha must also be specified\n  #   3) specify neither sigma_mean nor sigma_var, in which case alpha and beta must be specified\n  \n  #-------- option 1\n  if (!is.null(sigma_mean) & !is.null(sigma_var)) {\n    \n    # if using fixed sigma model then no need to calculate alpha and beta. Otherwise use values of sigma_mean and sigma_var to search for the unique alpha and beta that define the distribution\n    if (sigma_var==0) {\n      cat('Using fixed sigma model')\n    } else {\n      cat('Using sigma_mean and sigma_var to define prior on sigma')\n      ab <- get_alpha_beta(sigma_mean, sigma_var)\n      alpha <- ab$alpha\n      beta <- ab$beta\n    }\n    \n    #-------- option 2\n  } else if (!is.null(sigma_mean) & is.null(sigma_var)) {\n    \n    if (!is.null(sigma_squared_shape)) {\n      cat('Using sigma_mean and sigma_squared_shape to define prior on sigma')\n      alpha <- sigma_squared_shape\n      if (alpha<=1) { stop('sigma_squared_shape must be >1') }\n      beta <- exp(2*log(sigma_mean) + 2*lgamma(alpha) - 2*lgamma(alpha-0.5))\n      epsilon <- sqrt(beta)*gamma(alpha-0.5)/gamma(alpha)\n      sigma_var <- beta/(alpha-1)-epsilon^2\n    }\n    \n    #-------- option 3\n  } else if (is.null(sigma_mean) & is.null(sigma_var)) {\n    \n    if (!is.null(sigma_squared_shape) & !is.null(sigma_squared_rate)) {\n      cat('Using sigma_squared_shape and sigma_squared_rate to define prior on sigma')\n      alpha <- sigma_squared_shape\n      beta <- sigma_squared_rate\n      sigma_mean <- sqrt(beta)*gamma(alpha-0.5)/gamma(alpha)\n      sigma_var <- beta/(alpha-1)-sigma_mean^2\n    }\n    \n  }\n  \n  # check that chosen inputs do in fact uniquely define the distribution. At this stage alpha and beta are only allowed to be NULL under the fixed-sigma model\n  if (is.null(alpha) | is.null(beta)) {\n    returnError <- TRUE\n    if (!is.null(sigma_var)) {\n      if (sigma_var==0) {\n        returnError <- FALSE\n      }\n    }\n    if (returnError) {\n      stop(\"Current prior parameters on sigma do not fully specify the distribution. Must specify either 1) a prior mean and variance on sigma, 2) a prior mean on sigma and a prior shape on sigma^2, 3) a prior shape and prior rate on sigma^2.\")\n    }\n  }\n  \n  # set model parameters\n  model <- list(sigma_mean=sigma_mean, sigma_var=sigma_var, sigma_squared_shape=alpha, sigma_squared_rate=beta, priorMean_longitude=priorMean_longitude, priorMean_latitude=priorMean_latitude, tau=tau, alpha_shape=alpha_shape, alpha_rate=alpha_rate)\n  \n  # set MCMC parameters\n  MCMC <- list(chains=chains, burnin=burnin, samples=samples, burnin_printConsole=burnin_printConsole, samples_printConsole=samples_printConsole)\n  \n  # set output parameters    \n  output <- list(longitude_minMax=longitude_minMax, latitude_minMax=latitude_minMax, longitude_cells=longitude_cells, latitude_cells=latitude_cells)\n  \n  # combine and return\n  ret <- list(model=model, MCMC=MCMC, output=output)\n  return(ret)\n}\n#------------------------------------------------\n#' Import shapefile\n#'\n#' This function imports spatial information in the form of SpatialPolygonsDataFrame, SpatialLinesDataFrame or RasterLayer for use with geoMask().\n#'\n#' @param fileName the object to be imported. Must be one of SpatialPolygonsDataFrame, SpatialLinesDataFrame or RasterLayer if it is to be used with geoMask().\n#'\n#' @export\n#' @examples\n#' # load London boroughs by default\n#' geoShapefile()\n\ngeoShapefile <- function(fileName=NULL) {\n  \n  # load north London boroughs by default\n  if (is.null(fileName)) {\n    fileName <- system.file('extdata', 'London_north', package='RgeoProfile')\n  }\n  \n  # load shapefile\n  ret <- readOGR(fileName, verbose=FALSE)\n  \n  return(ret)\n}\n\n#------------------------------------------------\n#' Check data\n#'\n#' Check that all data for use in Rgeoprofile MCMC is in the correct format.\n#'\n#' @param data a data list object, as defined by geoData().\n#' @param silent whether to report if data passes checks to console.\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' geoDataCheck(d)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' geoDataCheck(d)\n\ngeoDataCheck <- function(data, silent=FALSE) {\n    \n  # check that data is a list\n  stopifnot(is.list(data))\n  \n  # check that contains longitude and latitude\n  stopifnot(\"longitude\" %in% names(data))\n  stopifnot(\"latitude\" %in% names(data))\n  \n  # check that data values are correct format and range\n  stopifnot(is.numeric(data$longitude))\n  stopifnot(all(is.finite(data$longitude)))\n  stopifnot(is.numeric(data$latitude))\n  stopifnot(all(is.finite(data$latitude)))\n  \n  # check same number of observations in logitude and latitude, and n>1\n  stopifnot(length(data$longitude)==length(data$latitude))\n  stopifnot(length(data$longitude)>1)\n  \n  # if passed all checks\n  if (!silent) { cat(\"data file passed all checks\\n\") }\n}\n\n#------------------------------------------------\n#' Check parameters\n#'\n#' Check that all parameters for use in Rgeoprofile MCMC are in the correct format.\n#'\n#' @param params a list of parameters, as defined by geoParams().\n#' @param silent whether to report passing check to console.\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' geoParamsCheck(p)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_var=0)\n#' geoParamsCheck(p)\n\ngeoParamsCheck <- function(params, silent=FALSE) {\n  \n  # check that params is a list\n  if (!is.list(params))\n    stop(\"params must be in list format\")\n      \n  # check that contains 'model', 'MCMC' and 'output' as sublists\n  if (!\"model\"%in%names(params) | !\"MCMC\"%in%names(params) | !\"output\"%in%names(params))\n    stop(\"params must contain sublists 'model', 'MCMC' and 'output'\")\n\n  # check that 'model', 'MCMC' and 'output' are indeed lists\n  if (!is.list(params$model))\n    stop(\"params$model must be in list format\")\n  if (!is.list(params$MCMC))\n    stop(\"params$MCMC must be in list format\")\n  if (!is.list(params$output))\n    stop(\"params$output must be in list format\")\n\n  #---------------------------------------\n\n  # check that params$model contains all necessary parameters\n  if (!(\"sigma_mean\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'sigma_mean'\")\n  if (!(\"sigma_var\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'sigma_var'\")\n  if (!(\"sigma_squared_shape\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'sigma_squared_shape'\")\n  if (!(\"sigma_squared_rate\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'sigma_squared_rate'\")\n  if (!(\"priorMean_longitude\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'priorMean_longitude'\")\n  if (!(\"priorMean_latitude\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'priorMean_latitude'\")\n  if (!(\"tau\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'tau'\")\n  if (!(\"alpha_shape\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'alpha_shape'\")\n  if (!(\"alpha_rate\"%in%names(params$model)))\n    stop(\"params$model must contain parameter 'alpha_rate'\")\n\n  # check that params$model values are correct format and range\n  if (!is.numeric(params$model$sigma_mean) | !is.finite(params$model$sigma_mean))\n    stop(\"params$model$sigma_mean must be numeric and finite\")\n  if (params$model$sigma_mean<=0)\n    stop(\"params$model$sigma_mean must be greater than 0\")\n  if (!is.numeric(params$model$sigma_var) | !is.finite(params$model$sigma_var))\n    stop(\"params$model$sigma_var must be numeric and finite\")\n  if (params$model$sigma_var<0)\n    stop(\"params$model$sigma_var must be greater than or equal to 0\")\n  \n  # the only time that sigma_squared_shape and sigma_squared_rate are allowed to be NULL is under the fixed sigma model\n  if (is.null(params$model$sigma_squared_shape) | is.null(params$model$sigma_squared_rate)) {\n    if (params$model$sigma_var!=0) {\n      stop('params$model$sigma_squared_shape and params$model$sigma_squared_rate can only be NULL under the fixed sigma model, i.e. when params$model$sigma_var==0. ')\n    }\n  }\n  \n  if (!is.null(params$model$sigma_squared_shape)) {\n    if (!is.numeric(params$model$sigma_squared_shape) | !is.finite(params$model$sigma_squared_shape))\n      stop(\"params$model$sigma_squared_shape must be numeric and finite\")\n  }\n  if (!is.null(params$model$sigma_squared_rate)) {\n    if (!is.numeric(params$model$sigma_squared_rate) | !is.finite(params$model$sigma_squared_rate))\n      stop(\"params$model$sigma_squared_rate must be numeric and finite\")\n  }\n  if (!is.numeric(params$model$priorMean_longitude) | !is.finite(params$model$priorMean_longitude))\n    stop(\"params$model$priorMean_longitude must be numeric and finite\")\n  if (!is.numeric(params$model$priorMean_latitude) | !is.finite(params$model$priorMean_latitude))\n    stop(\"params$model$priorMean_latitude must be numeric and finite\")\n  if (!is.numeric(params$model$tau) | !is.finite(params$model$tau))\n    stop(\"params$model$tau must be numeric and finite\")\n  if (params$model$tau<=0)\n    stop(\"params$model$tau must be greater than 0\")\n  if (!is.numeric(params$model$alpha_shape) | !is.finite(params$model$alpha_shape))\n    stop(\"params$model$alpha_shape must be numeric and finite\")\n  if (params$model$alpha_shape<=0)\n    stop(\"params$model$alpha_shape must be greater than 0\")\n  if (!is.numeric(params$model$alpha_rate) | !is.finite(params$model$alpha_rate))\n    stop(\"params$model$alpha_rate must be numeric and finite\")\n  if (params$model$alpha_rate<=0)\n    stop(\"params$model$alpha_rate must be greater than 0\")\n\n  #---------------------------------------\n\n  # check that params$MCMC contains all necessary parameters\n  if (!(\"chains\"%in%names(params$MCMC)))\n    stop(\"params$MCMC must contain parameter 'chains'\")\n  if (!(\"burnin\"%in%names(params$MCMC)))\n    stop(\"params$MCMC must contain parameter 'burnin'\")\n  if (!(\"samples\"%in%names(params$MCMC)))\n    stop(\"params$MCMC must contain parameter 'samples'\")\n  if (!(\"burnin_printConsole\"%in%names(params$MCMC)))\n    stop(\"params$MCMC must contain parameter 'burnin_printConsole'\")\n  if (!(\"samples_printConsole\"%in%names(params$MCMC)))\n    stop(\"params$MCMC must contain parameter 'samples_printConsole'\")\n  \n  # check that params$MCMC values are correct format and range\n  if (!is.numeric(params$MCMC$chains) | !is.finite(params$MCMC$chains))\n    stop(\"params$MCMC$chains must be numeric and finite\")\n  if (params$MCMC$chains<=1)\n    stop(\"params$MCMC$chains must be 2 or more\")\n  if (!is.numeric(params$MCMC$burnin) | !is.finite(params$MCMC$burnin))\n    stop(\"params$MCMC$burnin must be numeric and finite\")\n  if (params$MCMC$burnin<0)\n    stop(\"params$MCMC$burnin must be greater than or equal to 0\")\n  if (!is.numeric(params$MCMC$samples) | !is.finite(params$MCMC$samples))\n    stop(\"params$MCMC$samples must be numeric and finite\")\n  if (params$MCMC$samples<=0)\n    stop(\"params$MCMC$samples must be greater than 0\")\n  if (!is.numeric(params$MCMC$burnin_printConsole) | !is.finite(params$MCMC$burnin_printConsole))\n    stop(\"params$MCMC$burnin_printConsole must be numeric and finite\")\n  if (params$MCMC$burnin_printConsole<=0)\n    stop(\"params$MCMC$burnin_printConsole must be greater than 0\")\n  if (!is.numeric(params$MCMC$samples_printConsole) | !is.finite(params$MCMC$samples_printConsole))\n    stop(\"params$MCMC$samples_printConsole must be numeric and finite\")\n  if (params$MCMC$samples_printConsole<=0)\n    stop(\"params$MCMC$samples_printConsole must be greater than 0\")\n  \n  #---------------------------------------\n  \n  # check that params$output contains all necessary parameters\n  if (!(\"longitude_minMax\"%in%names(params$output)))\n    stop(\"params$output must contain parameter 'longitude_minMax'\")\n  if (!(\"latitude_minMax\"%in%names(params$output)))\n    stop(\"params$output must contain parameter 'latitude_minMax'\")\n  if (!(\"longitude_cells\"%in%names(params$output)))\n    stop(\"params$output must contain parameter 'longitude_cells'\")\n  if (!(\"latitude_cells\"%in%names(params$output)))\n    stop(\"params$output must contain parameter 'latitude_cells'\")\n  \n  # TODO: SOME MORE CHECKS ON FORMAT OF params$output?\n  \n  #---------------------------------------\n  \n  # if passed all checks\n  if (!silent) { cat(\"params file passed all checks\\n\") }\n}\n\n#------------------------------------------------\n#' MCMC under Rgeoprofile model\n#'\n#' This function carries out the main MCMC under the Rgeoprofile model. Posterior draws are smoothed to produce a posterior surface, and converted into a geoProfile. Outputs include posterior draws of alpha and sigma under the variable-sigma model.\n#'\n#' @param data input data in the format defined by geoData().\n#' @param params input parameters in the format defined by geoParams().\n#' @param lambda bandwidth to use in posterior smoothing. If NULL then optimal bandwidth is chosen automatically by maximum-likelihood.\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p, lambda=0.05)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n\ngeoMCMC <- function(data, params, lambda=NULL) {\n  \n  # check that data and parameters in correct format\n  geoDataCheck(data)\n  geoParamsCheck(params)\n  cat(\"\\n\")\n  \n  # extract ranges etc. from params object\n  min_lon <- params$output$longitude_minMax[1]\n  max_lon <- params$output$longitude_minMax[2]\n  min_lat <- params$output$latitude_minMax[1]\n  max_lat <- params$output$latitude_minMax[2]\n  cells_lon <- params$output$longitude_cells\n  cells_lat <- params$output$latitude_cells\n  cellSize_lon <- (max_lon-min_lon)/cells_lon\n  cellSize_lat <- (max_lat-min_lat)/cells_lat\n  breaks_lon <- seq(min_lon, max_lon, l=cells_lon+1)\n  breaks_lat <- seq(min_lat, max_lat, l=cells_lat+1)\n  mids_lon <- breaks_lon[-1] - cellSize_lon/2\n  mids_lat <- breaks_lat[-1] - cellSize_lat/2\n  mids_lon_mat <- outer(rep(1,length(mids_lat)), mids_lon)\n  mids_lat_mat <- outer(mids_lat, rep(1,length(mids_lon)))\n  \n  # transform data to cartesian coordinates relative to centre of prior. After transformation data are defined relative to point 0,0 (i.e. the origin represents the centre of the prior). Add transformed coordinates to data object before feeding into C++ function\n  data_cartesian <-latlon_to_cartesian(params$model$priorMean_latitude, params$model$priorMean_longitude, data$latitude, data$longitude)\n  data$x <- data_cartesian$x\n  data$y <- data_cartesian$y\n  \n  # if using fixed sigma model then change alpha and beta from NULL to -1. This value will be ignored, but needs to be numeric before feeding into the C++ function.\n  if (params$model$sigma_var==0) {\n      params$model$sigma_squared_shape <- -1\n      params$model$sigma_squared_rate <- -1\n  }\n  \n  # carry out MCMC using efficient C++ function\n  rawOutput <- C_geoMCMC(data, params)\n  \n  # extract mu draws and convert from cartesian to lat/lon coordinates\n  mu_draws <- cartesian_to_latlon(params$model$priorMean_latitude, params$model$priorMean_longitude, rawOutput$mu_x, rawOutput$mu_y)\n  \n  # produce smoothed surface\n  mu_smooth <- geoSmooth(mu_draws$longitude, mu_draws$latitude, breaks_lon, breaks_lat, lambda)\n  \n  # calculate coordinates of lat/lon matrix in original cartesian coordinates\n  cart <-latlon_to_cartesian(params$model$priorMean_latitude, params$model$priorMean_longitude, mids_lat_mat, mids_lon_mat)\n  \n  # produce prior matrix. Note that each cell of this matrix contains the probability density at that point multiplied by the size of that cell, meaning the total sum of the matrix from -infinity to +infinity would equal 1. However, as the matrix is limited to the region specified by the limits, in reality this matrix will usually sum to less than 1.\n  priorMat <- dnorm(cart$x, sd=params$model$tau) * dnorm(cart$y, sd=params$model$tau) * (cellSize_lon*cellSize_lat)\n  \n  # combine prior surface with stored posterior surface (the prior never fully goes away under the DPM model)\n  n <- length(data$longitude)\n  alpha <- rawOutput$alpha\n  posteriorMat <-  mu_smooth + priorMat*mean(alpha/(alpha+n))\n  \n  # produce geoprofile\n  gp <- geoProfile(posteriorMat)\n  \n  # calculate posterior allocation\n  allocation <- matrix(unlist(rawOutput$allocation), n, byrow=T)\n  allocation <- data.frame(allocation/params$MCMC$samples)\n  names(allocation) <- paste(\"group\", 1:ncol(allocation), sep=\"\")\n  \n  # get single best posterior grouping\n  bestGrouping <- apply(allocation, 1, which.max)\n  \n  # calculate posterior co-allocation\n  coAllocation <- matrix(unlist(rawOutput$coAllocation), n, byrow=T)/params$MCMC$samples\n  diag(coAllocation) <- 1\n  coAllocation[row(coAllocation)>col(coAllocation)] <- NA\n  \n  # finalise output format\n  output <- list()\n  output$priorSurface <-  priorMat\n  output$posteriorSurface <-  posteriorMat\n  output$geoProfile <-  gp\n  output$midpoints_longitude <- mids_lon\n  output$midpoints_latitude <- mids_lat\n  output$sigma <- rawOutput$sigma\n  output$alpha <- alpha\n  output$allocation <- allocation\n  output$bestGrouping <- bestGrouping\n  output$coAllocation <- coAllocation\n  \n  return(output)\n}\n\n#------------------------------------------------\n#' Calculate geoprofile from surface\n#'\n#' Converts surface to hitscore percentage\n#'\n#' @param surface matrix to convert to geoprofile\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p, lambda=0.05)\n#' gp <- geoProfile(m$posteriorSurface)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' gp <- geoProfile(m$posteriorSurface)\n\ngeoProfile <- function(surface) {\n  \n  # check that surface is in correct format\n  stopifnot(is.matrix(surface))\n  \n  # create geoprofile from surface\n  ret <- matrix(rank(surface, ties.method=\"first\"), nrow=nrow(surface), byrow=FALSE)\n  ret[is.na(surface)] <- NA\n  ret <- 100 * (1 - (ret-1)/max(ret, na.rm=TRUE))\n  \n  return(ret)\n}\n\n#------------------------------------------------\n#' Calculate hitscores\n#'\n#' Calculate hitscores of the potential sources for a given surface (usually the geoprofile).\n#'\n#' @param params input parameters in the format defined by geoParams().\n#' @param source longitude and latitude of one or more source locations in the format defined by geoDataSource().\n#' @param surface the surface from which to calculate hitscores. Usually an object produced by geoProfile().\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' s <- geoDataSource(WaterPumps$longitude, WaterPumps$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p, lambda=0.05)\n#' geoReportHitscores(params = p, source = s, surface = m$geoProfile)\n#' \ngeoReportHitscores <- function(params, source, surface) {\n  \n  # check parameters\n  geoParamsCheck(params, silent = TRUE)\n  \n  # get size of cells\n  delta_lat <- diff(params$output$latitude_minMax)/params$output$latitude_cells\n  delta_lon <- diff(params$output$longitude_minMax)/params$output$longitude_cells\n  \n  # get index of closest point to each source\n  index_lat <- round((source$latitude - params$output$latitude_minMax[1])/delta_lat + 0.5)\n  index_lon <- round((source$longitude - params$output$longitude_minMax[1])/delta_lon + 0.5)\n  \n  # combine coordinates and indices in data frame\n  df <- data.frame(latitude = source$latitude, longitude = source$longitude, index_lat = index_lat, index_lon = index_lon)\n  \n  # drop rows if index outside range, with warning\n  df <- subset(df, index_lat>0 & index_lat<nrow(surface) & index_lon>0 & index_lon<ncol(surface))\n  if (nrow(df) < length(source$longitude)) {\n    warning(\"some sources outside range of surface\")\n  }\n  \n  # append hitscore percentages\n  df$hs <- surface[as.matrix(df[,c(\"index_lat\", \"index_lon\")])]\n  \n  # return subset of data frame\n  ret <- subset(df, select=c(\"latitude\", \"longitude\", \"hs\"))\n  return(ret)\n}\n\n#------------------------------------------------\n#' Extract latitude and longitude of points identified as sources by geoMCMC()\n#' \n#' This function takes the output of geoMCMC() and, for each 'crime', extracts the group to which it is assigned with the highest probability. For each group, the model returns the mean lat/long of all crimes assigned to that group.\n#' \n#' @param mcmc Model output in the format produced by geoMCMC().\n#' @param data Crime site data, in the format produced by geoData().\n#' \n#' @export\n#' @examples\n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=10, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' s <- geoDataSource(sim$source_lon, sim$source_lat)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' # extract sources identified by the model\n#' ms <- geoModelSources(mcmc = m, data = d)\n#' # plot data showing the sources identified by the model (note: NOT the actual suspect sites)\n#' geoPlotMap(data = d, source = ms, params = p, breakPercent = seq(0, 10, 1), \n#'                   mapType = \"roadmap\", surfaceCols =c(\"red\", \"orange\",\"yellow\",\"white\"),\n#'                   crimeCol = \"black\", crimeCex = 2, sourceCol = \"red\", sourceCex = 2,\n#'                   surface = m$geoProfile, gpLegend=TRUE, opacity = 0.4)\n\ngeoModelSources <- function (mcmc, data) {\n  \n  # get mean over data, split by best group\n  lon <- mapply(mean, split(data$longitude, mcmc$bestGrouping))\n  lat <- mapply(mean, split(data$latitude, mcmc$bestGrouping))\n  \n  return(list(longitude=lon, latitude=lat))\n}\n\n#------------------------------------------------\n#' Produces a surface based on an alternative ring-search strategy\n#'\n#' Produces a surface based on an alternative ring-search strategy (ie searching in an expanding radius out from the 'crimes'). The output from this function can be used with geoProfile() and geoReportHitscores to produce a map and hitscores based on this strategy.\n#'\n#' @param params Parameters list in the format defined by geoParams().\n#' @param data Data object in the format defined by geoData().\n#' @param source Potential sources object in the format defined by geoDataSource().\n#' @param mcmc mcmc object of the form produced by geoMCMC(). \n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' s <- geoDataSource(WaterPumps$longitude, WaterPumps$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' surface_ring <- geoRing(params = p, data = d, source = s, mcmc = m)\n#' gp_ring <- geoProfile(surface = surface_ring)\n#' map <- geoPlotMap(params = p, data = d, source = s, surface = gp_ring, \n#' opacity = 1, breakPercent = seq(0,50,l=21))\n#' map\n\n\ngeoRing <- function(params, data, source, mcmc) {\n  \n  # Calculates the percentage of the grid that must be searched before reaching each source under a ring search strategy. This search strategy assumes that we start from a given crime and search outwards in a circle of increasing radius until we reach a source. As there are multiple crimes the strategy assumes a separate individual searching from each crime simultaneously at an equal rate.\n  # The basic logic of the approach here is that calculating the final search radius needed to identify a source is easy - it is simply the minimum radius from any crime to this source. The difficulty is calculating the amount of grid that will have been explored by the time we reach this radius, as circles will often overlap and the intersection should not be double-counted (we assume searching moves on if the area has already been explored by someone else). This is done by brute force - a grid is created and cells are filled in solid if they have been explored. The total percentage of filled cells gives the hitscore percentage. The distance matrices used in this brute force step are needed repeatedly, and so they are computed once at the begninning to save time.\n  \n  # get number of crimes and sources\n  n <- length(data$latitude)\n  ns <- length(source$source_latitude)\n  \n  # create matrices giving lat/lon at all points in search grid\n  lonVec <- mcmc$midpoints_longitude\n  latVec <- mcmc$midpoints_latitude\n  lonMat <- matrix(rep(lonVec,each=length(latVec)), length(latVec))\n  latMat <- matrix(rep(latVec,length(lonVec)), length(latVec))\n  \n  # calculate great circle distance from every data point to every point in search grid. This list of distance matrices will be used multiple times so best to pre-compute here.\n  ret <- matrix(-Inf, nrow=nrow(lonMat), ncol=ncol(lonMat))\n  for (i in 1:n) {\n    neg_dist_i <- -latlon_to_bearing(data$latitude[i], data$longitude[i], latMat, lonMat)$gc_dist\n    ret[neg_dist_i>ret] <- neg_dist_i[neg_dist_i>ret]\n  }\n  \n  # return negative distance\n  return(ret)\n}\n\n#------------------------------------------------\n#' Incorporate shapefile or raster information into a geoprofile\n#' \n#' This function allows information from a shapefile or raster to be incorporated within the geoprofile. For example, we might wish to exclude areas not on land, or weight the probabilities within a specific postcode differently. The spatial object used should be a SpatialPolygonsDataFrame as produced by the package sp or a raster. \n#' \n#' @param probSurface the original geoprofile, usually the object $posteriorSurface produced by geoMCMC().\n#' @param params an object produced by geoParams().\n#' @param mask the spatial information to include. Must be one of SpatialPolygonsDataFrame, SpatialLinesDataFrame or RasterLayer.\n#' @param scaleValue different functions depending on value of \"operation\". For \"inside' or \"outside\", the value by which probabilities should be multiplied inside or outside the shapefile. However, note that using scaleValue = 0 can cause too many ties to plot contours properly; instead, use a very low value such as 1e-9. For \"near\" and \"far\", scaleValue is the importance of proximity to, or distance from, the object described in the SpatialPolygonsDataFrame, SpatialLinesDataFrame or RasterLayer. Thus, the default value of scaleValue = 1 can be increased to exaggerate the importance of proximity or distance. Not used for \"continuous\".\n#' @param operation how to combine the surface and the new spatial information. Must be one of \"inside\", \"outside\", \"near\", \"far\" or \"continuous\". The first two multiply areas inside or outside the area described in the shapefile (or raster) by scaleValue. \"near\" or \"far\" weight the geoprofile by its closeness to (or distance from) the area described in the shapefile (or raster). Finally, \"continuous\" uses a set of numerical values (eg altitude) to weight the geoprofile. NOTE: 'near' and 'far' can take a few minutes to run.\n#' @param maths one of \"add\", \"subtract\", multiply\" or \"divide. The mathematical operation used to combine the new spatial data with the geoprofile when operation = \"continuous\".\n#' \n#' @export\n#' @examples\n#' # load London example data and set params\n#' d <- LondonExample_crimes\n#' s <- LondonExample_sources\n#' p = geoParams(data = d, sigma_mean = 1, sigma_squared_shape = 2)\n#' # run model\n#' m = geoMCMC(data = d, params = p)\n#' \n#' # plot original map\n#' map1 <- geoPlotMap(params = p, data = d, source = s, surface = m$geoProfile)\n#' map1\n#' \n#' # mask out North London and replot\n#' north_london_mask <- geoShapefile()\n#' prob_masked <- geoMask(probSurface = m$posteriorSurface, params = p, mask = north_london_mask,\n#'                 operation = \"inside\", scaleValue = 1e-9)\n#' gp_masked <- geoProfile(prob_masked$prob)\n#' # plot new surface\n#' map2 <- geoPlotMap(params = p, data = d, source = s, surface = gp_masked)\n#' map2\n#' \n#'# repeat, restricting mask to Tower Hamlets and using 'near' instead of 'inside'\n#'TH_mask <- north_london_mask[which(north_london_mask$NAME == \"Tower Hamlets\"),]\n#'prob_masked2 <- geoMask(probSurface = m$posteriorSurface, params = p, mask = TH_mask, \n#'                 operation = \"far\", scaleValue = 1)\n#'gp_masked2 <- geoProfile(prob_masked2$prob)\n#'# plot new surface\n#'map3 <- geoPlotMap(params = p, data = d, source = s, surface = gp_masked2)\n#'map3\n\ngeoMask <- function (probSurface, params, mask, scaleValue = 1, operation = \"inside\", maths = \"multiply\") {\n  \n  # check input formats\n  stopifnot(class(mask) %in% c(\"SpatialPolygonsDataFrame\", \"RasterLayer\",\"SpatialLinesDataFrame\"))\n  stopifnot(operation %in% c(\"inside\", \"outside\", \"near\", \"far\", \"continuous\"))\n  stopifnot(maths %in% c(\"multiply\", \"divide\", \"add\", \"subtract\", \"continuous\"))\n  \n  # convert mask to raster\n  if (class(mask) == \"RasterLayer\") { \n    rf <- mask\n  } else if (class(mask) == \"SpatialPolygonsDataFrame\") {\n    tmp <- raster(ncol = params$output$longitude_cells, nrow = params$output$latitude_cells)\n    extent(tmp) <- extent(mask)\n    rf <- rasterize(mask, tmp)\n  } else if (class(mask) == \"SpatialLinesDataFrame\") {\n    tmp <- raster(ncol = params$output$longitude_cells, nrow = params$output$latitude_cells)\n    extent(tmp) <- extent(mask)\n    rf <- rasterize(mask, tmp)\n  }\n  \n  # convert probSurface to raster\n  raster_probSurface <- raster(probSurface, xmn = params$output$longitude_minMax[1], xmx = params$output$longitude_minMax[2], ymn = params$output$latitude_minMax[1], ymx = params$output$latitude_minMax[2], crs=\"+proj=longlat +datum=WGS84\")\n  \n  # project mask onto same coordinate system as probSurface\n  rf <- projectRaster(rf, raster_probSurface, crs=\"+proj=longlat +datum=WGS84\")\n  \n  # extract raster values to matrices\n  rf_mat <- matrix(rf@data@values, ncol = rf@ncols, byrow = TRUE)\n  rf_mat <- rf_mat[nrow(rf_mat):1,]\n  p_mat <- matrix(raster_probSurface@data@values, ncol = raster_probSurface@ncols, byrow = TRUE)\n  \n  #### OPERATIONS\n  \n  # initialise scale matrix\n  scale_mat <- NULL\n  \n  # keep cells inside mask, multiplied by scaleValue\n  if (operation == \"inside\") {\n    scale_mat <- scaleValue * ifelse(is.na(rf_mat), 1, scaleValue)\n    p_mat <- p_mat * scale_mat\n  }\n  \n  # keep cells outside mask, multiplied by scaleValue\n  if (operation == \"outside\") {\n    scale_mat <- scaleValue * ifelse(is.na(rf_mat), scaleValue, 1)\n    p_mat <- p_mat * scale_mat\n  }\n  \n  # perform operation at all cells\n  if (operation == \"continuous\") {\n    if (maths == \"add\") { \n      p_mat <- p_mat + rf_mat\n    }\n    if (maths == \"subtract\") {\n      p_mat <- p_mat - rf_mat\n    }\n    if (maths == \"multiply\") {\n      p_mat <- p_mat * rf_mat\n    }\n    if (maths == \"divide\") {\n      p_mat <- p_mat / rf_mat\n    }\n  }\n  \n  # decay with distance from non-NA cells\n  if (operation == \"near\") {\n    d <- distance(rf)\n    d_mat <- matrix(d@data@values, ncol = d@ncols, byrow = TRUE)\n    d_mat <- d_mat[nrow(d_mat):1,]\n    scale_mat <- 1/(d_mat^scaleValue)\n    scale_mat[scale_mat == \"Inf\"] <- 1\n    p_mat <- p_mat * scale_mat\n  }\n  \n  # increase with distance from non-NA cells\n  if (operation == \"far\") {\n    d <- distance(rf)\n    d_mat <- matrix(d@data@values, ncol = d@ncols, byrow = TRUE)\n    d_mat <- d_mat[nrow(d_mat):1,]\n    scale_mat <- d_mat^scaleValue\n    p_mat <- p_mat * scale_mat\n  }\n  \n  # return list\n  ret <- list(prob = p_mat, scaleMatrix = scale_mat)\n  return(ret)\n}\n",
    "created" : 1523020327774.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3063118224",
    "id" : "A3924B5B",
    "lastKnownWriteTime" : 1524731306,
    "last_content_update" : 1524731306,
    "path" : "~/Dropbox/Bob/Work/My Programs/Geoprofiling/RgeoProfile/R/mainFunctions.R",
    "project_path" : "R/mainFunctions.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}