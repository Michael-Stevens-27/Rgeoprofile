{
    "collab_server" : "",
    "contents" : "\n#------------------------------------------------\n# ggplot theme that gets rid of all margins etc.\n# credit to the Wilke lab and cowplot package for original code that this is taken from (https://github.com/wilkelab/cowplot)\n# (not exported)\n\ntheme_nothing <- function(font_size = 14, font_family = \"\"){\n  theme_void(base_size = font_size, base_family = font_family) %+replace%\n    theme(\n      line = element_blank(),\n      rect = element_blank(),\n      text = element_text(\n        family = font_family, face = \"plain\",\n        colour = \"black\", size = font_size,\n        lineheight = 0.9, hjust = 0.5, vjust = 0.5, angle = 0,\n        margin = margin(), debug = FALSE\n      ),\n      \n      axis.line =          element_blank(),\n      axis.line.x =        NULL,\n      axis.line.y =        NULL,\n      axis.text =          element_blank(),\n      axis.text.x =        element_blank(),\n      axis.text.x.top =    element_blank(),\n      axis.text.y =        element_blank(),\n      axis.text.y.right =  element_blank(),\n      axis.ticks =         element_blank(),\n      axis.ticks.length =  unit(0, \"pt\"),\n      axis.title.x =       element_blank(),\n      axis.title.x.top =   element_blank(),\n      axis.title.y =       element_blank(),\n      axis.title.y.right = element_blank(),\n      \n      legend.background =  element_blank(),\n      legend.spacing =     unit(0.4, \"cm\"),\n      legend.spacing.x =   NULL,\n      legend.spacing.y =   NULL,\n      legend.margin =      margin(0.2, 0.2, 0.2, 0.2, \"cm\"),\n      legend.key =         element_blank(),\n      legend.key.size =    unit(1.2, \"lines\"),\n      legend.key.height =  NULL,\n      legend.key.width =   NULL,\n      legend.text =        element_text(size = rel(0.8)),\n      legend.text.align =  NULL,\n      legend.title =       element_text(hjust = 0),\n      legend.title.align = NULL,\n      legend.position =    \"none\",\n      legend.direction =   NULL,\n      legend.justification = \"center\",\n      legend.box =         NULL,\n      legend.box.margin =  margin(0, 0, 0, 0, \"cm\"),\n      legend.box.background = element_blank(),\n      legend.box.spacing = unit(0.4, \"cm\"),\n      \n      panel.background =   element_blank(),\n      panel.border =       element_blank(),\n      panel.grid.major =   element_blank(),\n      panel.grid.minor =   element_blank(),\n      panel.spacing =      unit(0, \"pt\"),\n      panel.spacing.x =    NULL,\n      panel.spacing.y =    NULL,\n      panel.ontop    =     FALSE,\n      \n      strip.background =   element_blank(),\n      strip.text =         element_blank(),\n      strip.text.x =       element_blank(),\n      strip.text.y =       element_blank(),\n      strip.placement =    \"inside\",\n      strip.placement.x =  NULL,\n      strip.placement.y =  NULL,\n      strip.switch.pad.grid = unit(0., \"cm\"),\n      strip.switch.pad.wrap = unit(0., \"cm\"),\n      \n      plot.background =    element_blank(),\n      plot.title =         element_blank(),\n      plot.subtitle =      element_blank(),\n      plot.caption =       element_blank(),\n      plot.margin =        margin(0, 0, 0, 0),\n      \n      complete = TRUE\n    )\n}\n\n#------------------------------------------------\n#' Plot prior and posterior distributions of sigma.\n#'\n#' Plot prior distribution of sigma as defined by current parameter values. Can optionally overlay a kernel density plot of posterior draws of sigma.\n#'\n#' @param params a list of parameters as defined by geoParams().\n#' @param mcmc stored output obtained by running geoMCMC(). Leave as NULL to plot prior only.\n#' @param plotMax maximum x-axis range to plot. Leave as NULL to use default settings.\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' p <- geoParams(data = d, sigma_mean = 0.2, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' geoPlotSigma(params = p, mcmc = m)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' geoPlotSigma(params = p, mcmc = m)\n\ngeoPlotSigma <- function(params, mcmc=NULL, plotMax=NULL) {\n  \n  # check params\n  geoParamsCheck(params, silent=TRUE)\n  \n  # check that plotMax is sensible\n  if (!is.null(plotMax)) {\n    stopifnot(is.numeric(plotMax))\n    stopifnot(is.finite(plotMax))\n    stopifnot(plotMax>0)\n  }\n  \n  # extract sigma parameters\n  sigma_mean <- params$model$sigma_mean\n  sigma_var <- params$model$sigma_var\n  alpha <- params$model$sigma_squared_shape\n  beta <- params$model$sigma_squared_rate\n  \n  # stop if using fixed sigma model\n  if (sigma_var==0) { stop('can only produce this plot under variable-sigma model (i.e. sigma_var>0)') }\n  \n  # extract sigma draws from mcmc object\n  sigma_draws <- mcmc$sigma\n  \n  # default plotMax based on extent of prior distribution AND the extent of posterior draws if available\n  if (is.null(plotMax)) {\n    plotMax <- sigma_mean + 3*sqrt(sigma_var)\n    if (!is.null(sigma_draws)) {\n      plotMax <- max(plotMax, 2*max(sigma_draws, na.rm=TRUE))\n    }\n  }\n  \n  # produce prior distribution\n  sigma_vec <- seq(0, plotMax, l=501)\n  sigma_prior <- dRIG(sigma_vec, alpha, beta)\n  \n  # plot prior and overlay density of posterior draws if used\n  if (is.null(sigma_draws)) {\n    \n    plot(sigma_vec, sigma_prior, type='l', lty=1, xlab='sigma (km)', ylab='probability density', main='')\n    legend(x='topright', legend='prior', lty=1)\n    \n  } else {\n    \n    sigma_posterior <- density(sigma_draws, from=0, to=plotMax)\n    y_max <- max(sigma_posterior$y, na.rm=TRUE)\n    \n    plot(sigma_vec, sigma_prior, type='l', lty=1, ylim=c(0,y_max), xlab='sigma (km)', ylab='probability density', main='')\n    lines(sigma_posterior, lty=2)\n    legend(x='topright', legend=c('prior','posterior'), lty=c(1,2))\n  }\n  \n}\n\n#------------------------------------------------\n#' Plot posterior allocation\n#'\n#' Produces plot of posterior allocation from output of MCMC.\n#'\n#' @param mcmc stored output obtained by running geoMCMC().\n#' @param colours vector of colours for each allocation. If NULL then use default colour scheme.\n#' @param barBorderCol colour of borders around each bar. Set as NA to omit this border (useful when there are a large number of observations).\n#' @param barBorderWidth line width of borders around each bar.\n#' @param mainBorderCol colour of border around plot.\n#' @param mainBorderWidth line width of border around plot.\n#' @param yTicks_on whether to include ticks on the y-axis.\n#' @param yTicks vector of y-axis tick positions.\n#' @param xTicks_on whether to include ticks on the x-axis.\n#' @param xTicks_size size of ticks on the x-axis.\n#' @param xlab x-axis label.\n#' @param ylab x-axis label.\n#' @param mainTitle main title over plot.\n#' @param names individual names of each observation, written horizontally below each bar.\n#' @param names_size size of names under each bar.\n#' @param orderBy whether to order segments within each bar by \"group\" or by \"probability\". If ordered by group, all segments of a particular group are laid down before moving to the next group. If ordered by probability the segments within each bar are ordered from large to small.\n#'\n#' @export\n#' @examples\n#' # London example data\n#' d <- LondonExample_crimes\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' geoPlotAllocation(m)\n#'\n#' # John Snow cholera data\n#' d <- Cholera\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p, lambda=0.05)\n#' geoPlotAllocation(m, barBorderCol=NA)\t# (should allocate all to a single source!)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#'                51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' geoPlotAllocation(m)\n\ngeoPlotAllocation <- function(mcmc, colours=NULL, barBorderCol=NA, barBorderWidth=0.25, mainBorderCol=\"black\", mainBorderWidth=2, yTicks_on=TRUE, yTicks=seq(0,1,0.2), xTicks_on=FALSE, xTicks_size=1, xlab=\"\", ylab=\"posterior allocation\", mainTitle=\"\", names=NA, names_size=1, orderBy=\"group\") {\n  \n  # check that orderBy is either 'group' or 'probability'\n  if (!(orderBy %in% c(\"group\",\"probability\"))) {\n    stop(\"orderBy must equal 'group' or 'probability'\")\n  }\n  \n  # get allocation from mcmc object\n  allocation <- mcmc$allocation\n  \n  # check that allocation is a data frame\n  if (!is.data.frame(allocation)) {\n    stop(\"allocation must be a data frame, with observations in rows and groups in columns\")\n  }\n  \n  # extract useful parameters\n  n <- nrow(allocation)\n  k <- ncol(allocation)\n  \n  # replace colours if default\n  if (is.null(colours)) {\n    rawCols <- RColorBrewer::brewer.pal(n=11,name=\"RdYlBu\")\n    myPal <- colorRampPalette(rawCols)\n    colours <- myPal(k)\n    colours <- colours[c(2*(1:ceiling(k/2))-1,2*(1:floor(k/2)))]\n  }\n  \n  # if ordered by group\n  if (orderBy==\"group\") {\n    \n    plot(0, type='n', xlim=c(0,n), ylim=c(0,1), xlab=xlab, ylab=ylab, xaxs=\"i\", yaxs=\"i\",axes=FALSE, main=mainTitle)\n    barplot(t(allocation), col=colours, space=0, border=NA, axes=FALSE, add=TRUE)\n    segments(0:n,c(0,0),0:n,c(1,1), col=barBorderCol, lwd=barBorderWidth)\n    box(col=mainBorderCol, lwd=mainBorderWidth)\n    axis(2, tick=yTicks_on, labels=yTicks_on, at=yTicks)\n    axis(1, at=1:n-0.5, tick=xTicks_on, lwd.ticks=xTicks_size, labels=names, las=2, cex.axis=names_size)\n  }\n  \n  # if ordered by probability\n  if (orderBy==\"probability\") {\n    \n    plot(0, type='n', xlim=c(0,n), ylim=c(0,1), xlab=xlab, ylab=ylab, xaxs=\"i\", yaxs=\"i\",axes=FALSE, main=mainTitle)\n    tM <- t(allocation)\n    for (i in 1:n) {\n      temp <- tM\n      temp[,-i] <- NA\n      temp_order <- order(temp[,i],decreasing=TRUE)\n      barplot(temp[temp_order,], col=colours[temp_order], space=0, border=NA, axes=FALSE, add=TRUE)\n    }\n    segments(0:n,c(0,0),0:n,c(1,1), col=barBorderCol, lwd=barBorderWidth)\n    box(col=mainBorderCol, lwd=mainBorderWidth)\n    axis(2, tick=yTicks_on, labels=yTicks_on, at=yTicks)\n    axis(1, at=1:n-0.5, tick=xTicks_on, lwd.ticks=xTicks_size, labels=names, las=2, cex.axis=names_size)\n  }\n  \n}\n\n#------------------------------------------------\n# get optimal zoom level given x and y values\n# (not exported)\n\ngetZoom <- function(x,y) {\n  \n  # calculate midpoint of range in x and y\n  xmid <- min(x) + diff(range(x))/2\n  ymid <- min(y) + diff(range(y))/2\n  \n  # calculate delta (half of longitude range) for a range of zoom levels\n  z <- 20:2\n  delta <- 445/(2^z)\n  \n  # calculate left and right longitude limits at all zoom levels\n  long_angle_left <- xmid - delta\n  long_angle_right <- xmid + delta\n  \n  # calculate top and bottom latitude limits at all zoom levels\n  lat_angle <- ymid/360*2*pi\n  projection_mid <- log(tan(pi/4+lat_angle/2))\n  projection_top <- projection_mid + delta/360*2*pi\n  projection_bot <- projection_mid - delta/360*2*pi\n  lat_angle_top <- (2*atan(exp(projection_top))-pi/2)*360/(2*pi)\n  lat_angle_bot <- (2*atan(exp(projection_bot))-pi/2)*360/(2*pi)\n  \n  # find the most zoomed-in level that captures all points\n  zoomTest <- (min(x)>long_angle_left) & (max(x)<long_angle_right) & (min(y)>lat_angle_bot) & (max(y)<lat_angle_top)\n  if (!any(zoomTest)) {\n    stop(\"values are outside of plotting range of earth\")\n  }\n  bestZoom <- z[which(zoomTest)[1]]\n  \n  return(bestZoom)\n}\n\n#------------------------------------------------\n#' Plot a map and overlay data and/or geoprofile\n#'\n#' Plots geoprofile on map, with various customisable options.\n#'\n#' @param params parameters list in the format defined by geoParams().\n#' @param data data object in the format defined by geoData().\n#' @param source potential sources object in the format defined by geoDataSource().\n#' @param surface a surface to overlay onto the map, typically a geoprofile obtained from the output of geoMCMC().\n#' @param surfaceCols vector of two or more colours to plot surface. Defaults to viridis palette.\n#' @param zoom zoom level of map. If NULL then choose optimal zoom from params.\n#' @param latLimits optional vector setting min and max latitude for zoom view.\n#' @param lonLimits optional vector setting min and max longitude for zoom view.\n#' @param mapSource which online source to use when downloading the map. Options include Google Maps (\"google\"), OpenStreetMap (\"osm\"), Stamen Maps (\"stamen\") and CloudMade maps (\"cloudmade\").\n#' @param mapType the specific type of map to plot. Options available are \"terrain\", \"satellite\", \"roadmap\" and \"hybrid\" (google maps), \"terrain-background\", \"terrain\", \"watercolor\" and \"toner\" (stamen maps) or a positive integer for cloudmade maps (see ?get_cloudmademap from the package ggmap for details).\n#' @param opacity value between 0 and 1 givin the opacity of surface colours.\n#' @param plotContours whether or not to add contours to the surface plot.\n#' @param breakPercent vector of values between 0 and 100 describing where in the surface contours appear.\n#' @param contourCol single colour to plot contour lines showing boundaries on surface.\n#' @param smoothScale should plot legend show continuous (TRUE) or discrete (FALSE) colours.\n#' @param crimeCex relative size of symbols showing crimes.\n#' @param crimeCol colour of crime symbols.\n#' @param crimeBorderCol border colour of crime symbols.\n#' @param crimeBorderWidth width of border of crime symbols.\n#' @param sourceCex relative size of symbols showing suspect sites.\n#' @param sourceCol colour of suspect sites symbols.\n#' @param gpLegend whether or not to add legend to plot.\n#'\n#' @export\n#' @examples\n#' # London example data\n#' d <- LondonExample_crimes\n#' s <- LondonExample_sources\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' # produce simple map\n#' geoPlotMap(params = p, data = d, source = s, surface = m$geoProfile,\n#'                 breakPercent = seq(0, 50, 5), mapType = \"hybrid\",\n#'                 crimeCol = \"black\", crimeCex = 2, sourceCol = \"red\", sourceCex = 2)\n#'\n#' # John Snow cholera data\n#' d <- Cholera\n#' s <- WaterPumps\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p, lambda=0.05)\n#' # produce simple map\n#' geoPlotMap(params = p, data = d, source = s, surface = m$geoProfile,\n#'                 breakPercent = seq(0, 50, 5), mapType = \"hybrid\",\n#'                 crimeCol = \"black\", crimeCex = 2, sourceCol = \"red\", sourceCex = 2)\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' s <- geoDataSource(sim$source_lon, sim$source_lat)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' # change colour palette, map type, opacity and range of geoprofile and omit legend\n#' geoPlotMap(params = p, data = d, source = s, surface = m$geoProfile,\n#'                 breakPercent = seq(0, 30, 5), mapType = \"terrain\", \n#'                 surfaceCols = c(\"blue\",\"white\"), crimeCol = \"black\", \n#'                 crimeBorderCol = \"white\",crimeCex = 2, sourceCol = \"red\", sourceCex = 2,\n#'                 opacity = 0.7, gpLegend = FALSE)\n\ngeoPlotMap <- function(params, data=NULL, source=NULL, surface=NULL, surfaceCols=NULL, zoom=NULL, latLimits=NULL, lonLimits=NULL, mapSource=\"google\", mapType=\"hybrid\", opacity=0.6, plotContours=TRUE, breakPercent=seq(0,100,l=11), contourCol= \"grey50\", smoothScale=TRUE, crimeCex=1.5, crimeCol='red', crimeBorderCol='white', crimeBorderWidth=0.5, sourceCex=1.5, sourceCol='blue', gpLegend=TRUE) {\n  \n  # check that inputs make sense\n  geoParamsCheck(params)\n  if (!is.null(data)) { geoDataCheck(data) }\n  \n  # set defaults\n  if (is.null(surfaceCols)) { surfaceCols <- viridis::plasma(100) }\n  if (is.null(latLimits)) { latLimits <- params$output$latitude_minMax }\n  if (is.null(lonLimits)) { lonLimits <- params$output$longitude_minMax }\n  \n  # if zoom==\"auto\" then set zoom level based on params\n  if (is.null(zoom)) { \n    zoom <- getZoom(params$output$longitude_minMax, params$output$latitude_minMax)\n    cat(paste0(\"using zoom=\", zoom, \"\\n\"))\n  }\n  \n  # make zoom level appropriate to map source\n  if (mapSource==\"stamen\") { zoom <- min(zoom,18) }\n  \n  # download map\n  cat(\"downloading map\\n\")\n  loc <- c(mean(params$output$longitude_minMax), mean(params$output$latitude_minMax))\n  rawMap <- get_map(location=loc, zoom=zoom, source=mapSource, maptype=mapType)\n  \n  # get attributes from rawMap (bounding box)\n  att <- unlist(attributes(rawMap)$bb)\n  latVec <- seq(att[3], att[1], l=nrow(rawMap))\n  lonVec <- seq(att[2], att[4], l=ncol(rawMap))\n  df_rawMap <- data.frame(lat=rep(latVec, each=ncol(rawMap)), lon=rep(lonVec, times=nrow(rawMap)))\n  \n  # bind with colours from rawMap\n  df_rawMap <- cbind(df_rawMap, col=as.vector(rawMap))\n  \n  # create ggplot object\n  myMap <- ggplot(df_rawMap, aes_string(x='lon', y='lat', fill='col')) + geom_raster() + scale_fill_identity()\n  myMap <- myMap + coord_cartesian(xlim=lonLimits, ylim=latLimits, expand=FALSE)\n  \n  # overlay geoprofile\n  if (!is.null(surface)) {\n    \n    # create colour palette\n    geoCols <- colorRampPalette(rev(surfaceCols))\n    nbcol <- length(breakPercent)-1\n    \n    # extract plotting ranges and determine midpoints of cells\n    longitude_minMax  <- params$output$longitude_minMax\n    latitude_minMax  <- params$output$latitude_minMax\n    longitude_cells  <- params$output$longitude_cells\n    latitude_cells  <- params$output$latitude_cells\n    longitude_cellSize <- diff(longitude_minMax)/longitude_cells\n    latitude_cellSize <- diff(latitude_minMax)/latitude_cells\n    longitude_midpoints <- longitude_minMax[1] - longitude_cellSize/2 + (1:longitude_cells)* longitude_cellSize\n    latitude_midpoints <- latitude_minMax[1] - latitude_cellSize/2 + (1:latitude_cells)* latitude_cellSize\n    \n    # create data frame of x,y,z values and labels for contour level\n    df <- expand.grid(x=longitude_midpoints, y=latitude_midpoints)\n    df$z <- as.vector(t(surface))\n    labs <- paste(round(breakPercent,1)[-length(breakPercent)],\"-\",round(breakPercent,1)[-1],\"%\",sep='')\n    df$cut <- cut(df$z, breakPercent, labels=labs)\n    df$col <- rev(geoCols(nbcol))[df$cut]\n    \n    # remove all entries outside of breakPercent range\n    df_noNA <- df[!is.na(df$cut),]\n    \n    # convert current map into borderless background image\n    background <- myMap + theme_nothing()\n    myMap <- ggplot() + annotation_custom(grob=ggplotGrob(background), xmin=lonLimits[1], xmax=lonLimits[2], ymin=latLimits[1], ymax=latLimits[2])\n    \n    # add surface and colour scale\n    if (smoothScale) {\n      myMap <- myMap + geom_raster(aes_string(x='x', y='y', fill='z'), alpha=opacity, data=df_noNA)\n      myMap <- myMap + scale_fill_gradientn(name=\"Hitscore\\npercentage\", colours=rev(surfaceCols))\n    } else {\n      myMap <- myMap + geom_raster(aes_string(x='x', y='y', fill='col'), alpha=opacity, data=df_noNA)\n      myMap <- myMap + scale_fill_manual(name=\"Hitscore\\npercentage\", labels=labs, values=geoCols(nbcol))\n    }\n    if (!gpLegend) {\n      myMap <- myMap + theme(legend.position=\"none\")\n    }\n    \n    # add plotting limits\n    myMap <- myMap + coord_cartesian(xlim=lonLimits, ylim=latLimits, expand=FALSE)\n    \n    # add contours\n    if (plotContours) {\n      myMap <- myMap + stat_contour(aes_string(x='x', y='y', z='z'), colour=contourCol, breaks=breakPercent, size=0.3, alpha=opacity, data=df)\n    }\n  }\n  \n  # overlay data points\n  if (!is.null(data)) {\n    df_data <- data.frame(longitude=data$longitude, latitude=data$latitude)\n    myMap <- myMap + geom_point(aes_string(x='longitude', y='latitude'), data=df_data, pch=21, stroke=crimeBorderWidth, cex=crimeCex, fill=crimeCol, col=crimeBorderCol)\n  }\n  \n  # overlay source points\n  if (!is.null(source)) {\n    df_source <- data.frame(longitude=source$longitude, latitude=source$latitude)\n    myMap <- myMap + geom_point(aes_string(x='longitude', y='latitude'), data=df_source, pch=15, cex=sourceCex, col=sourceCol, fill=NA)\n  }\n  \n  # force correct aspect ratio\n  centre_lat <- mean(params$output$latitude_minMax)\n  centre_lon <- mean(params$output$longitude_minMax)\n  scale_lat <- latlon_to_bearing(centre_lat, centre_lon, centre_lat + 0.1, centre_lon)$gc_dist\n  scale_lon <- latlon_to_bearing(centre_lat, centre_lon, centre_lat, centre_lon + 0.1)$gc_dist\n  asp <- diff(latLimits)*scale_lat / (diff(lonLimits)*scale_lon)\n  myMap <- myMap +  theme(aspect.ratio=asp)\n  \n  # add labels\n  myMap <- myMap +  labs(x=\"longitude\", y=\"latitude\")\n  \n  # plot map\n  myMap\n}\n\n#------------------------------------------------\n#' Perspective plot of geoprofile or raw probabilities\n#'\n#' Plots persp plot of geoprofile or posterior surface (coloured according to height), reducing matrix dimensions if necessary to avoid grid lines being too close together. NB Only works with square matrix\n#'\n#' @param surface surface to plot; either the geoprofile or posteriorSurface output by geoMCMC(). \n#' @param aggregate_size the number of cells to aggregate to smooth the surface.\n#' @param surface_type type of surface; should be either \"gp\" for geoprofile or \"prob\" for posteriorSurface.\n#' @param perspCol colour palette. Defaults to red/orange/yellow/white.\n#' @param phiGP value of phi to pass to persp().\n#' @param thetaGP value of theta to pass to persp().\n#'\n#' @export\n#' @examples\n#' # John Snow cholera data\n#' d <- geoData(Cholera$longitude, Cholera$latitude)\n#' s <- geoDataSource(WaterPumps$longitude, WaterPumps$latitude)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p, lambda=0.05)\n#' # raw probabilities\n#' geoPersp(m$posteriorSurface, surface_type = \"prob\")\n#' # geoprofile\n#' geoPersp(m$geoProfile, aggregate_size = 3, surface_type = \"gp\")\n#' \n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=1, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' s <- geoDataSource(sim$source_lon, sim$source_lat)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' # raw probabilities\n#' geoPersp(m$posteriorSurface, surface_type = \"prob\")\n#' # geoprofile\n#' geoPersp(surface = m$geoProfile, aggregate_size = 3, surface_type = \"gp\")\n\ngeoPersp <- function(surface, aggregate_size=3, surface_type=\"gp\", perspCol=c(\"red\", \"orange\", \"yellow\", \"white\"), phiGP=30, thetaGP=-30) {\n  \n  # rescale and transform surface\n  scale <- 1\n  if(surface_type==\"gp\") { scale <- -1 }\n  surface <- t(scale*surface)\n  \n  # reduce matrix or not\n  matrix_size <- unique(dim(surface))[1]\n  breaks <- seq(1, (matrix_size-(aggregate_size-1)), aggregate_size)\n  nb <- length(breaks)\n  output <- matrix(NA, nrow=nb, ncol=nb)\n  for (i in 1:nb) {\n    for (j in 1:nb) {\n      output[i,j] <- mean(as.vector(surface[breaks[i]:(breaks[i]+(aggregate_size-1)), breaks[j]:(breaks[j]+(aggregate_size-1))]))\n    }\n  }\n  \n  # Generate the desired number of colors\n  colpal <- colorRampPalette(perspCol)\n  color <- colpal(100)\n  \n  # Compute the z-value at the facet centres\n  ncz <- ncol(output)\n  nrz <- nrow(output)\n  zfacet <- output[-1, -1] + output[-1, -ncz] + output[-nrz, -1] + output[-nrz, -ncz]\n  facetcol <- cut(zfacet, length(color))\n  \n  persp(output, col=color[facetcol], border=\"black\", phi=phiGP, theta=thetaGP, lwd=0.2, box=FALSE)\n}\n\n#------------------------------------------------\n#' Produce Lorenz Plot\n#'\n#' Produces a Lorenz plot showing the proportion of suspect sites or cimes identified as a function of area and calculates\n#' the corresponding Gini coefficient using trapezoid rule.\n#' Also allows an optional vector called crimeNumbers with numbers of crimes per suspect site; the length of this vector\n#' should equal the number of suspect sites. If this is present, the function calculates and returns the Gini coefficient \n#' based on the number of crimes; otherwise, this is calculated based on the number of suspect sites.\n#'\n#' @param hit_scores object in the format defined by geoReportHitscores().\n#' @param crimeNumbers optional vector with numbers of crimes per suspect site.\n#' @param suspects_col colour to plot curve for sources.\n#' @param crimes_col colour to plot curve for crimes if crimeNumbers is supplied.\n#'\n#' @export\n#' @examples\n#' # London example data\n#' d <- LondonExample_crimes\n#' s <- LondonExample_sources\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' hs <- geoReportHitscores(params = p, source = s, surface = m$geoProfile)\n#' hs \n#' # Lorenz plot on sources\n#' geoPlotLorenz(hs)\n#' # Lorenz plot on sources and crimes\n#' # extract numbers of crimes allocated per source as a proxy\n#' cn <- as.vector(table(m$bestGrouping))\n#' geoPlotLorenz(hs, crimeNumbers = cn)\n\ngeoPlotLorenz <- function(hit_scores, crimeNumbers=NULL, suspects_col=\"red\", crimes_col=\"blue\") {\n  \n  # trapezoid rule\n  tpzd <- function(x,y) {\n    idx = 2:length(x)\n    return (as.double( (x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2)\n  }\n  \n  # bind crimeNumbers if using\n  crimeNumbers_on <- !is.null(crimeNumbers)\n  if (crimeNumbers_on) {\n    hit_scores <- cbind(hit_scores, crimeNumbers)\n  }\n  \n  # put hitscore data frame in increasing order\n  hit_scores <- hit_scores[order(hit_scores[,3]),]\n  hs <- hit_scores[,3]\n  n <- nrow(hit_scores)\n  \n  # cumulative crime sites\n  cum_suspect_sites <- (1:n)/n\n  \n  # add initial 0 and terminal 1 to each so plots will begin at (0,0) and end at (1,1)\n  hs <- c(0,hs,100)\n  cum_suspect_sites <- c(0,cum_suspect_sites,1)\n  \n  # calculate gini coefficient for crimes\n  auc <- (tpzd(hs/100, cum_suspect_sites) - 0.5)/0.5\n  G_sources <- round(auc,3)\n  \n  # produce plot\n  if (!crimeNumbers_on) {\n    \n    # plot\n    plot(0, type=\"n\", xlim=c(0,100), ylim=c(0,1), xlab=\"hit score percentage\", ylab=\"proportion identified\")\n    abline(h=seq(0,1,0.2), v=seq(0,100,20), col=\"lightgray\", lwd=0.4)\n    abline(0, 0.01, col=\"gray\")\n    lines(hs, cum_suspect_sites, col=suspects_col)\n    \n    # add Gini value text and legend\n    Gini_text <- paste0(\"G (sources) = \",G_sources)\n    legend(60, 0.4, Gini_text, cex=0.8, bty=\"n\")\n    legend(65, 0.25, c(\"sources\"), col=c(suspects_col), lwd=1, cex=0.8)\n    \n    # return Gini value(s) silently\n    invisible(c(G_sources=G_sources))\n    \n  } else {\n    \n    # cumulative crime numbers\n    cum_crimes <- cumsum(hit_scores[,4])/sum(hit_scores[,4])\n    cum_crimes <- c(0,cum_crimes,1)\n    \n    # calculate gini coefficient for crimes\n    auc <- (tpzd(hs/100, cum_crimes) - 0.5)/0.5\n    G_crimes <- round(auc,3)\n    \n    # plot\n    plot(0, type=\"n\", xlim=c(0,100), ylim=c(0,1), xlab=\"hit score percentage\", ylab=\"proportion identified\")\n    abline(h=seq(0,1,0.2), v=seq(0,100,20), col=\"lightgray\", lwd=0.4)\n    abline(0, 0.01, col=\"gray\")\n    lines(hs, cum_suspect_sites, col=suspects_col)\n    lines(hs, cum_crimes, col=crimes_col)\n    \n    # add Gini value text and legend\n    Gini_text <- c(paste0(\"G (sources) = \",G_sources), paste0(\"G (incidents) = \",G_crimes))\n    legend(60, 0.5, Gini_text, cex=0.8, bty=\"n\")\n    legend(65, 0.25, c(\"sources\",\"incidents\"), col=c(suspects_col,crimes_col), lwd=1, cex=0.8)\n    \n    # return Gini value(s) silently\n    invisible(c(G_sources=G_sources, G_incidents=G_crimes))\n  }\n  \n}\n\n#------------------------------------------------\n#' Calculate and plot probability of coallocation\n#'\n#' For all pairs of crimes, calculates the probability that both originate from the same source and plots a coloured half matrix representing these data. The data underlying these calculations can be accessed as the object $coAllocation produced by geoMCMC().\n#'\n#' @param mcmc object of the type output by geoMCMC().\n#' @param cols colour palette to use. Defaults to viridis palette.\n#'\n#' @export\n#' @examples\n#' # London example data\n#' d <- LondonExample_crimes\n#' s <- LondonExample_sources\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' # produce simple map\n#' geoPlotMap(params = p, data = d, source = s, surface = m$geoProfile,\n#'                 breakPercent = seq(0, 50, 5), mapType = \"hybrid\",\n#'                 crimeCol = \"black\", crimeCex = 2, sourceCol = \"red\", sourceCex = 2)\n#' # calculate coallocation matrix and plot\n#' geoPlotCoallocation(m)\n\ngeoPlotCoallocation <- function(mcmc, cols=NULL) {\n  \n  # default colours\n  if (is.null(cols)) {\n    cols <- viridis::viridis(100)\n  }\n  \n  # get co-allocation matrix from raw MCMC output\n  comat <- mcmc$coAllocation\n  \n  # produce data frame for ggplot\n  n <- nrow(comat)\n  df <- data.frame(x=as.vector(row(comat)), y=as.vector(col(comat)), z=as.vector(t(comat)))\n  \n  # produce plot\n  gg <- ggplot(df) + geom_tile(aes_string(x='x', y='y', fill='z')) + scale_fill_gradientn(colours=cols, name=\"Probability\\nco-allocation\") + coord_cartesian(xlim=c(0.5,n+0.5), ylim=c(0.5,n+0.5), expand=FALSE) + labs(x=\"observation\", y=\"observation\")\n  \n  gg\n}\n\n#------------------------------------------------\n#' Unknown pleasures\n#' \n#' A frivolous alternative to geoPlotMap(), this function takes the output of geoMCMC() and plots the resulting geoprofile in the style of the cover of Joy Division's 'Unknown pleasures' album.\n#' \n#' @param input_matrix The surface to plot, usually the object $geoProfile produced by geoMCMC().\n#' @param nlines The number of lines (defaults to the correct number of 80).\n#' @param paper_ref A text string, for example a reference to a paper.\n#' @param bgcol Background colour\n#' @param fgcol Foreground colour\n#' @param wt line weight\n#' \n#' @export\n#' @examples\n#' # simulated data\n#' sim <-rDPM(50, priorMean_longitude = -0.04217491, priorMean_latitude = \n#' 51.5235505, alpha=10, sigma=1, tau=3)\n#' d <- geoData(sim$longitude, sim $latitude)\n#' s <- geoDataSource(sim$source_lon, sim$source_lat)\n#' p <- geoParams(data = d, sigma_mean = 1.0, sigma_squared_shape = 2)\n#' m <- geoMCMC(data = d, params = p)\n#' unknownPleasures(m$geoProfile, paper_ref = \"Rgeoprofile v2.1.0\")\n\nunknownPleasures <- function(input_matrix, paper_ref = NULL, nlines = 80, bgcol = \"black\", fgcol = \"white\", wt = 2) {\n  \n  orig_prof <- input_matrix\n  citation <- paper_ref\n  # extract other params\n  ncols <- ncol(orig_prof)\n  # functions\n  expandMatrix <- function(mat,output_long,output_lat)\n  {\n    # define function expanding vector\n    expandVector <- function(input_vec,output_length)\n    {\n      my_vec <- input_vec\n      desired_length <- output_length\n      new_vec <- rep(NA, desired_length)\n      \n      vec_ID <- seq(1,length(my_vec),length=desired_length)\n      \n      for(i in 1:length(new_vec))\n      {\n        ifelse(vec_ID[i] %% 1 == 0,\n               new_vec[i] <- my_vec[floor(vec_ID[i])],\n               new_vec[i] <- mean((1-vec_ID[i] %% 1) * my_vec[floor(vec_ID[i])] + (vec_ID[i] %% 1) * my_vec[ceiling(vec_ID[i])])\n        )\n      }\n      return(new_vec)\n    }\n    mat1 <- apply(mat,2, function(x) expandVector(x, output_long))\n    mat2 <- apply(mat1,1, function(x) expandVector(x, output_lat))\n    return(t(mat2))\t\n  }\n  \n  # reduce to manageable number of rows and columns!\n  reduced_mat <- expandMatrix(orig_prof ,nlines, ncols)\n  \n  # scale so values fall between -0.5 and +0.5\n  reduced_mat <- 1-reduced_mat/max(reduced_mat)-0.5\n  \n  # set y coordinates of lines\n  yvals <- seq(0, 1,length = nlines)\n  \n  # plot\n  oldPar <- par(bg = bgcol)\n  on.exit(par(oldPar))\n  \n  plot(1:ncols, reduced_mat[nlines,]+yvals[nlines], type=\"l\", ylim=c(-1,max(yvals)+0.5), axes=FALSE, xlab=\"\", ylab=\"\", col=fgcol)\n  \n  for (i in nlines:1) {\n    polygon(c(min(reduced_mat[i,]), reduced_mat[i,]+yvals[i], min(reduced_mat[i,])), col=bgcol, border=bgcol)\n    points(1:ncol(reduced_mat), reduced_mat[i,]+yvals[i], type=\"l\", col=fgcol, lwd=wt)\n  }\n  text(0,-0.6,citation,adj=0,col=fgcol)\n}\n",
    "created" : 1523021508107.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "911402484",
    "id" : "CA7DEFBC",
    "lastKnownWriteTime" : 1523608155,
    "last_content_update" : 1523608155,
    "path" : "~/Dropbox/Bob/Work/My Programs/Geoprofiling/RgeoProfile/R/plotting.R",
    "project_path" : "R/plotting.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}