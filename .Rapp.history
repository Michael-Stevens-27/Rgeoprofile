library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    #old.par <- par(no.readonly = TRUE)#
	lm <- ifelse(is.null(lm), matrix(1,1,1), lm)#
    print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m, lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
matrix(1,1,1)
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    #old.par <- par(no.readonly = TRUE)#
	lm <- ifelse(is.null(lm), matrix(1,1,1), lm)#
    print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    #old.par <- par(no.readonly = TRUE)#
    print(lm)#
	lm <- ifelse(is.null(lm), matrix(1,1,1), lm)#
    print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
is.null(lm)
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    #old.par <- par(no.readonly = TRUE)#
    print(lm)#
	lm <- ifelse(is.null(lm), lm, matrix(1,1,1))#
    print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    #old.par <- par(no.readonly = TRUE)#
    print(lm)#
	if (is.null(lm)) {#
		lm <- matrix(1,1,1)#
	}#
    print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
par()
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
	if (is.null(lm)) {#
		lm <- matrix(1, par()$mfrow[1], par()$mfrow[2])#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m)#
#foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
	if (is.null(lm)) {#
		lm <- matrix(1, par()$mfrow[1], par()$mfrow[2])#
	}#
	print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m)#
#foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
mfrow
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:mfrow[1]* mfrow[2], mfrow[1], mfrow[2])#
	}#
	print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m)#
#foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2])#
	}#
	print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m)#
#foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
	print(lm)#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	#big.par <- par(no.readonly = TRUE)#
	#mfg.save <- par()$mfg#
	#par(mfg = mfg.save)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- #
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m)#
#foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- 1#
	print(mfg)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m)#
#foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
print(thisPlot)
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	print(mfg)#
	print(thisPlot)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
foo(m)#
#foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	print(mfg)#
	print(thisPlot)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm==thisPlot+1, arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm==thisPlot+1, arr.ind=TRUE)[1,]#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    layout( cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5)) )#
    par(mfg=c(2,2,7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm==thisPlot+1, arr.ind=TRUE)[1,]#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	#print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm==thisPlot+1, arr.ind=TRUE)[1,]#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:5) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm==thisPlot+1, arr.ind=TRUE)[1,]#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm==thisPlot+1, arr.ind=TRUE)[1,]#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    par(mfg=c(5, 2, 7,2))#
    #par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	if (is.null(lm)) {#
		mfrow <- par()$mfrow#
		lm <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm==thisPlot+1, arr.ind=TRUE)[1,]#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    par(mfg=c(2, 2, 7,2))#
    #par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==thisPlot, arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    par(mfg=c(2, 2, 7,2))#
    #par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==thisPlot, arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    #par(mfg=c(nextPlot[1], , 7,2))#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    #par(mfg=c(nextPlot[1], , 7,2))#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 4)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:4, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:4, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:3) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:3) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot()
image.plot
function (..., add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
function (..., add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
foo <- function (..., add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
foo <- function (..., lm = NULL, add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
par(NULL)
header()
library(viridis)#
#
foo <- function (..., lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(r, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
r
?image
image(m)
m <- matrix(rnorm(100^2),100)
win()
image(m)
image(m, useRaster=TRUE)
?image
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)
image(m, useRaster=TRUE)
image(m)
plot(5)
image(m)
plot(5)
image(m, useRaster=TRUE)
m <- matrix(rnorm(gridSize^2), gridSize)
image(m, useRaster=TRUE)
image(m)
image(m, useRaster=TRUE)
layout
library(viridis)#
#
#quickRaster <- function (z, lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (z, lm = NULL, ...) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)
quickRaster(m)
image
? imagePlotInfo
library(viridis)#
#
quickRaster <- function (..., lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
quickRaster(m, layout_mat=lm)
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
?image.plot
quickRaster(m, layout_mat=lm, breaks=c(0,1))
quickRaster(m, layout_mat=lm, breaks=c(0,1), col=1:2)
quickRaster(m, layout_mat=lm, breaks=c(0,1), col=1)
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=c(0,1), col=1)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
seq(-1,1)
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
imagePlotInfo
seq(0,5,n=100)
seq(0,5,l=100)
imageplot.setup
?imageplot.setup
?image.plot
image.plot
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    if (is.null(breaks)) {#
    		midpoints <- seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), l=nlevel)#
    		delta <- (midpoints[2] - midpoints[1])/2#
    		breaks <- c(midpoints[1] - delta, midpoints + delta)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	print(temp)#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    if (is.null(breaks)) {#
    		midpoints <- seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), l=nlevel)#
    		delta <- (midpoints[2] - midpoints[1])/2#
    		breaks <- c(midpoints[1] - delta, midpoints + delta)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
#par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    if (is.null(breaks)) {#
    		midpoints <- seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), l=nlevel)#
    		delta <- (midpoints[2] - midpoints[1])/2#
    		breaks <- c(midpoints[1] - delta, midpoints + delta)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(x, breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(x, breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(x, breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, axis.args=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster
faster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:4, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(m, layout_mat=lm, breaks=seq(-1,1))
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
imagePlotInfo
?imagePlotInfo
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)+1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)+1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    	print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)+1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    	print(length(breaks))#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    	print(length(breaks))#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1,0.5))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1,0.5))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(m, layout_mat=lm)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(m, layout_mat=lm, horizontal=TRUE)
win(2,2)
faster(m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}
faster(m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}
faster(m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}
faster(m, layout_mat=lm, horizontal=TRUE)
faster(m, layout_mat=NULL, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=NULL, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
?image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    		legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    #axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
    #        mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
    #        axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    #axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
    #        mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
    #        axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=FALSE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)
plot(f1)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
plot(f1)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- exp(-z/(2*N))#
lines(f2)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2, col=2)
N <- 100#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2, col=2)
N <- 100#
#
z <- 0:500#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2, col=2)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
}#
#
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=FALSE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
}
image.plot
myFunctions()
pieCharts
pieCharts(0,0)
win()
plot(0,0)
pieCharts(0,0, c(0.5,0.2,0.3))
pieCharts(0,0, c(5,0.2,0.3))
pieCharts(0,0, c(50,0.2,0.3))
pieCharts(0,0, c(0.5))
?pieCharts
pieCharts(0,0, 1:10)
pieCharts
pieCharts(0,0, list(1:4))
pieCharts(0,0, list(1:4), col=bobFireIce())
pieCharts(0,0, list(1:4), seg_col=bobFireIce())
pieCharts(0,0, list(1:4), seg_col=bobFireIce(10))
pieCharts(0,0, list(1:4), seg_col=bobFireIce(4))
myFunctions()
library(bobFunctions)
myFunctions()
headEr()
header*
()
header()
install_github('bobverity/bobFunctions')
library(devTools)
library(devtools)
install_github('bobverity/bobFunctions')
library(bobFunctions)
myFunctions()
?faster
faster
# Siadjeu_fixBugs.R#
#
# Author: Bob Verity#
# Date: 2018-03-02#
#
# Purpose:#
# When analysing complex data sets in MavericK, some rungs may be poorly-mixing leading to point estimates that are obviously outside the general trend of the other rungs. The real solution to this problem is to improve MCMC mixing through techniques such as Metropolis coupling. However, until this is fix is implemented, an adequate short-term solution is to manually drop rungs that obviously under-estimate the likelihood. When the signal in the data is strong, this dropping of bad rungs is unlikely to influence the final results.#
# This script takes data in the form saved by outputEvidenceDetails.csv, recalculates thermodynamic integral estimates without bad rungs (user-specified), and recalculates normalised evidence by simulation.#
#
# ------------------------------------------------------------------#
# UTILITY FUNCTIONS#
#
# read in outputEvidenceDetails data frame and list of bad rungs to drop for each K. Return thermodynamic integral estimate of model evidence (in log space)#
getTI <- function(x, badRungs) {#
	# loop over all rows of input data#
	TI_mean <- TI_var <- rep(NA, nrow(x))#
	for (i in 1:nrow(x)) {#
		# get TI point means and standard errors#
		TIpoint_mean <- unlist(x[i, grepl("TIpoint_mean", names(x))])#
		TIpoint_SE <- unlist(x[i, grepl("TIpoint_SE", names(x))])#
		r <- length(TIpoint_mean)#
		# filter out bad rungs#
		beta <- seq(0,1,l=r)[!(1:r %in% badRungs[[i]])]#
		TIpoint_mean <- TIpoint_mean[!(1:r %in% badRungs[[i]])]#
		TIpoint_SE <- TIpoint_SE[!(1:r %in% badRungs[[i]])]#
		r <- length(beta)#
		# get mean and variance of TI estimator#
		d <- diff(beta)#
		TI_mean[i] <- 0.5*(TIpoint_mean[1]*d[1] + TIpoint_mean[r]*d[r-1]) + 0.5*sum( TIpoint_mean[-c(1,r)]*(d[-1]+d[-(r-1)]) )#
		TI_var[i] <- 0.25*((TIpoint_SE[1]*d[1])^2 + (TIpoint_SE[r]*d[r-1])^2) + 0.25*sum( (TIpoint_SE[-c(1,r)]*(d[-1]+d[-(r-1)]))^2 )#
	}#
	# return data frame#
	return(data.frame(K=x$K, log_evidence_mean=TI_mean, log_evidence_SE=sqrt(TI_var)))#
}#
#
# take TI estimates in log space and transform into linear space by simulation#
normalise_evidence <- function(df, reps=1e3) {#
	# calculate normalised evidence by simulation#
	sim_raw <- mapply(rnorm, n=reps, mean=df$log_evidence_mean, sd=df$log_evidence_SE)#
	sim_exp <- exp(sim_raw - max(sim_raw))#
	sim_norm <- sim_exp / outer(rowSums(sim_exp), rep(1,nrow(df)))#
	evidence_mean <- colMeans(sim_norm)#
	evidence_SE <- apply(sim_norm, 2, sd)#
	# return list of output#
	ret <- cbind(df, data.frame(evidence_mean=evidence_mean, evidence_SE=evidence_SE))#
	return(ret)#
}#
#
# ------------------------------------------------------------------#
# APPLICATION#
#
# read in data from file (change as needed)#
setwd("~/Desktop/")#
x <- read.csv("outputEvidenceDetails.csv")#
#
# manually state which rungs should be dropped. I've selected the ones I think are bad.#
badRungs <- list()#
badRungs[[2]] <- c(6, 15, 19)#
badRungs[[3]] <- c(6, 8, 10, 11, 13, 15:19, 21)#
badRungs[[4]] <- c(5, 7:10, 13, 15:17, 19:22)#
#
# recalculate TI estimator, dropping these bad rungs#
TI <- getTI(x, badRungs)#
#
# calculate normalised evidence estimates by simulation#
TI <- normalise_evidence(TI, reps=1e4)#
#
# plot in log space and natural space#
par(mfrow=c(1,2))#
plot(TI$K, TI$log_evidence_mean, xlab="K", ylab="log-evidence", main="log space")#
barplot(TI$evidence_mean, names=TI$K, xlab="K", ylab="evidence", main='natural space')#
#
# you can use standard errors in the TI object to produce error bars etc.#
TI
library(devtools)
setwd("~/Dropbox/Bob/Work/My Programs/Geoprofiling/RgeoProfile")
devtools::load_all()
#set.seed(1)#
#
# define parameters and draw some data#
n <- 1e2#
sigma_mean <- 1#
sigma_var <- 1#
sigma <- sigma_mean#
tau <- 10#
alpha <- 10
DPM_draws = rDPM(n, sigma=sigma, tau=tau, alpha=alpha, priorMean_longitude=-0.035, priorMean_latitude=51.52)
# some options for data#
# Note that Cholera and LondonExample_crimes are already loaded by default#
simData <- geoData(DPM_draws$longitude, DPM_draws$latitude)
# some options for sources#
# Note that WaterPumps and LondonExample_sources are already loaded by default#
simSource <- geoDataSource(DPM_draws$source_lon, DPM_draws$source_lat)
# choose data and sources from options above#
data <- LondonExample_crimes#
source <- LondonExample_sources
# set model and MCMC parameters#
params = geoParams(data = data, sigma_mean = sigma_mean, sigma_var = NULL, sigma_squared_shape = 2, chains = 5, burnin = 1e3, samples = 1e4, longitude_cells = 200, latitude_cells = 200)
# initial map of data#
# Note that geoPlotMap may occasionally fail to download map. In this case simply run again until it passes#
# Note also that plotting the map may take quite a long time#
map1 <- geoPlotMap(params = params, data = data, source = source)#
map1
# plot prior on sigma
# plot prior on sigma
geoPlotSigma(params = params)
# ------------------------------------------------------------------#
#
# run MCMC#
m = geoMCMC(data = data, params = params)
# ------------------------------------------------------------------#
#
# plot prior and posterior of sigma#
geoPlotSigma(params = params, mcmc = m)#
abline(v = sigma, col = 2)
# plot allocation#
geoPlotAllocation(mcmc = m)
geoPlotCoallocation(mcmc = m)
# plot profile on map#
map2 <- geoPlotMap(params = params, data = data, source = source, surface = m$geoProfile, breakPercent = seq(0,50,l=21), opacity = 0.8)#
map2
map2 <- geoPlotMap(params = params, data = data, source = source, surface = m$geoProfile, breakPercent = seq(0,50,l=21), opacity = 0.8)
map2
# plot zoomed in#
map3 <- geoPlotMap(lonLimits = c(-0.06,-0.02), latLimits = c(51.52, 51.54), params = params, data = data, source = source, surface = m$geoProfile, breakPercent = seq(0,50,l=21), opacity = 0.8)
map3
geoPersp(surface = m$geoProfile, aggregate_size = 1)
hs <- geoReportHitscores(params = params, source = source, surface =m$geoProfile)
hs
# produce Lorenz plot#
Gini <- geoPlotLorenz(hit_scores = hs)
Gini
# find centroids of data split by best grouping (placeholder for more thorough method)#
geoModelSources(mcmc = m, data = data)
# compare to geoprofile based on ring search strategy#
surface_ring <- geoRing(params = params, data = data, source = source, mcmc = m)#
gp_ring <- geoProfile(surface = surface_ring)
map4 <- geoPlotMap(params = params, data = data, source = source, surface = gp_ring, opacity = 1, breakPercent = seq(0,50,l=21))
map4
# hitscores of ring search geoprofile#
hs_ring <- geoReportHitscores(params = params, source = source, surface = gp_ring)#
hs_ring
Gini <- geoPlotLorenz(hit_scores = hs_ring)
Gini
# read in north London shapefile as mask#
north_london_mask <- geoShapefile()
prob_masked <- geoMask(m$posteriorSurface, params, north_london_mask, operation="inside", scaleValue=1)
gp_masked <- geoProfile(prob_masked$prob)
map5 <- geoPlotMap(params, data=data, source=source, surface=gp_masked, opacity=0.8)
map5
