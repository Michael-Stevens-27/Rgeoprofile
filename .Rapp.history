my_pts
seq(my_pts[1]:my_pts[2])
my_pts[1]
my_pts[2]
rev(seq(1,my_pts[1]))
seq(my_pts[1],my_pts[2])
seq(my_pts[1]+1,my_pts[2])
seq(my_pts[2],length(my_route))
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
seq(1,my_pts[1])#
#
rev(seq(my_pts[1]+1,my_pts[2]))#
#
seq(my_pts[2],length(my_route))
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
seq(1,my_pts[1])#
#
rev(seq(my_pts[1]+1,my_pts[2]))#
#
seq(my_pts[2]+1,length(my_route))
y_pts[2]
my_pts[2]
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
seq(1,my_pts[1])#
#
rev(seq(my_pts[1]+1,my_pts[2]))#
#
seq(my_pts[2]+1,length(my_route))
c(seq(1,my_pts[1]),rev(seq(my_pts[1]+1,my_pts[2]))#
,seq(my_pts[2]+1,length(my_route))#
)
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
seq(1,my_pts[1])#
#
rev(seq(my_pts[1]+1,my_pts[2]))#
#
seq(my_pts[2]+1,length(my_route))#
#
c(seq(1,my_pts[1]),rev(seq(my_pts[1]+1,my_pts[2]))#
,seq(my_pts[2]+1,length(my_route))#
)
my_pts
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
seq(1,my_pts[1])#
#
rev(seq(my_pts[1]+1,my_pts[2]))#
#
seq(my_pts[2]+1,length(my_route))#
#
c(seq(1,my_pts[1]),rev(seq(my_pts[1]+1,my_pts[2]))#
,seq(my_pts[2]+1,length(my_route))#
)
my_pts
my_route[my_pts[1]:my_pts[2]]
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
my_route[my_pts[1]:my_pts[2]] <- rev(seq(my_pts[1],my_pts[2]))#
my_route
new_route <- my_route
mutate_route <- function(my_route)#
{#
	my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route  <- new_route[my_pts[1]:my_pts[2]] <- new_route[my_pts[2]:my_pts[1]]#
return(new_route)#
}
mutate_route(12:15)
test_route <- sample(10,0,100,replace=FALSE)
test_route <- sample(10:0,100,replace=FALSE)
test_route <- sample(10:0,100,replace=TRUE)
test_route
test_route <- sample(0:100,10,replace=TRUE)
test_route <- sample(0:100,10,replace=TRUE)#
test_route#
mutate_route(test_route)
test_route
mutate_route <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route  <- new_route[my_pts[1]:my_pts[2]] <- seq(new_route[my_pts[2]:my_pts[1]])#
return(new_route)#
}#
#
test_route <- sample(0:100,10,replace=TRUE)#
test_route#
mutate_route(test_route)
mutate_route <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route[my_pts[1]:my_pts[2]] <- seq(new_route[my_pts[2]:my_pts[1]])#
return(new_route)#
}#
#
test_route <- sample(0:100,10,replace=TRUE)#
test_route#
mutate_route(test_route)
mutate_route <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route[my_pts[1]:my_pts[2]] <- new_route[my_pts[2:1]]#
return(new_route)#
}#
#
test_route <- sample(0:100,10,replace=TRUE)#
test_route#
mutate_route(test_route)
mutate_route <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route[my_pts[1]:my_pts[2]] <- new_route[my_pts[2]:my_pts[1]]]#
return(new_route)#
}#
#
test_route <- sample(0:100,10,replace=TRUE)#
test_route#
mutate_route(test_route)
my_pts[1]
my_pts[1:2]
seq(my_pts[1],my_pts[2])
new_route[seq(my_pts[1],my_pts[2])]
mutate_route <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route[seq(my_pts[1],my_pts[2])] <- new_route[seq(my_pts[2],my_pts[1])]#
return(new_route)#
}#
#
test_route <- sample(0:100,10,replace=TRUE)#
test_route#
mutate_route(test_route)
my_pts
my_route#
#
mutate_route <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route[seq(my_pts[1],my_pts[2])] <- new_route[seq(my_pts[2],my_pts[1])]#
return(new_route)#
}#
#
test_route <- sample(0:100,10,replace=TRUE)#
test_route#
mutate_route(test_route)
my_route
test_route <- sample(0:100,10,replace=FALSE)#
test_route#
mutate_route(test_route)
# This version calculate a cost of over- or under-allocation to staff automatically#
# This takes the sum, for each academic, of the number of spare places and raises#
# it to the fourth power. Thus, the penalties for going over increase geometrically.#
rm(list=ls())#
library(beepr)#
# define function#
#
allocationScore <- function(student_df,staff_df, choice_penalties)#
{#
number_choices <- ncol(student_df) - 2#
#
# count number of students for each staff member#
total_students <- rep(NA,length(staff_df$academic))#
#
for(i in 1:length(staff_df$academic))#
{#
	total_students[i] <- length(which(student_df$alloc==staff_df$academic[i]))#
}#
#total_students#
#
# calculate spare places#
spare_places <- staff_df$max_students-total_students#
#
# calculate allocation score#
alloc_score <- 0#
for(i in 1:length(choice_penalties))#
{#
		alloc_score <- alloc_score + choice_penalties[i] * sum(student_df[,i+1]== student_df[,number_choices+2])#
}#
# alloc_score#
#
# over-subscribed score#
over_score <- sum(as.integer(names(table(spare_places)))^6 * as.integer(table(spare_places)))#
#
# calculate allocation score#
count_alloc <- rep(NA,length(choice_penalties))#
for(i in 1:length(choice_penalties))#
{#
		count_alloc[i] <- sum(student_df[,i+1]== student_df[,length(choice_penalties)+2])#
}#
#
total_score <- alloc_score + over_score#
return(list(score=total_score, allocations = student_df$alloc, counts = table(student_df$alloc),spare=table(spare_places),choices= count_alloc))#
}#
#__________________________________________________#
# IMPORT DATA#
#__________________________________________________#
# import data#
students <- read.table("~/Dropbox/10 R code/project allocations/Input/student_input.txt",header=TRUE)#
attach(students)#
head(students)#
students$alloc <- as.character(students$alloc)#
str(students)#
students <- students[complete.cases(students),]#
#
staff <- read.table("~/Dropbox/10 R code/project allocations/Input/staff_input.txt",header=TRUE)#
attach(staff)#
head(staff)#
staff$academic <- as.character(staff$academic)#
str(staff)#
#staff$max_students <- rep(5, nrow(staff))#
number_students <- nrow(students)#
number_staff <- nrow(staff)#
number_choices <- 5#
#
# start with random allocation or with everyone assigned to their first choice#
random_choices <- sample(1:number_choices,length(students$alloc),replace=TRUE)#
for(i in 1:length(random_choices))#
{#
	students$alloc[i] <- as.character(students[i, (random_choices[i]+1)])#
}#
dim(students)#
students[,number_choices+2] <- as.character(students[,2])#
allocationScore(students,staff,c(0,1,5,10,100))#
#__________________________________________________#
# OPTIMISE#
#__________________________________________________#
# settings#
choice_penalties <- c(0,1,10,50,100)#
threshold_p_range <- c(0.005,0.1)#
generations <- 500#
mutants <- 100#
current_alloc <- students#
#
all_gen_scores <- rep(NA,generations+1)#
all_gen_scores[1] <- allocationScore(current_alloc,staff,choice_penalties)$score#
#
for(gen in 1:generations)#
{#
all_allocation_scores <- rep(NA,mutants+1)#
all_allocation_scores[1] <- allocationScore(current_alloc,staff,choice_penalties)$score#
#
allocation_list <- list(0)#
allocation_list[[1]] <- data.frame(current_alloc)#
# str(allocation_list)#
#
for(m in 1:mutants)#
{mutant_alloc <- current_alloc#
for(i in 1:nrow(mutant_alloc))#
{#
threshold_p <- runif(1, threshold_p_range[[1]],threshold_p_range[[2]])#
#
random_no <- runif(1,0,1)#
if(random_no<threshold_p)#
{new_choice <- sample(1:number_choices,1)#
mutant_alloc[i,(number_choices+2)] <- as.character(current_alloc[i,(new_choice+1)])}#
}#
all_allocation_scores[m+1] <- allocationScore(mutant_alloc,staff,choice_penalties)$score#
allocation_list[[m+1]] <- data.frame(mutant_alloc)#
#str(all_allocation_scores)#
#str(allocation_list)#
}#
#
# choose best current allocation#
best_alloc <- which(all_allocation_scores == min(all_allocation_scores))[1]#
#
current_alloc <- allocation_list[[best_alloc]]#
colnames(current_alloc) <- c("student_ID",as.character(seq(1: number_choices)),"alloc")#
#
all_gen_scores[gen+1] <- allocationScore(current_alloc,staff,choice_penalties)$score#
if (gen %% 10 ==0) {#
	print(c(gen,min(all_allocation_scores)))#
	par(mfrow=c(1,3))#
# score evolution#
#
plot(all_gen_scores,type="l",xlab="gen",ylab="score",log="y")#
# distribution of spare places#
barplot(allocationScore(current_alloc,staff,choice_penalties)$spare)#
#
# choice distribution#
barplot(allocationScore(current_alloc,staff,choice_penalties)$choices,names.arg=1:length(allocationScore(current_alloc,staff,choice_penalties)$choices))#
}#
}#
#__________________________________________________#
# OUTPUT#
#__________________________________________________#
write.table(current_alloc,"current_alloc.txt")#
#
# plot results#
par(mfrow=c(2,2))#
curve(x^6,-10,10,n=21,type="h",log="y",main="over allocation penalties",col="red",xlab="spare places")#
#
# score evolution#
plot(all_gen_scores,type="l",xlab="gen",ylab="score",log="y",main="scores",col="blue")#
#
# distribution of spare places#
barplot(allocationScore(current_alloc,staff,choice_penalties)$spare,ylab="freq",main="staff load",xlab="students per academic")#
#
# choice distribution#
barplot(allocationScore(current_alloc,staff,choice_penalties)$choices,names.arg=1:length(allocationScore(current_alloc,staff,choice_penalties)$choices),ylab="freq",main="student prefs",xlab="student preferences")#
allocationScore(students,staff,choice_penalties)#
allocationScore(current_alloc,staff,choice_penalties)#
beep(5)#
#
subset(current_alloc,current_alloc$alloc=="SLEC")#
#
prop_1_to_3 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[1:3])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_1_to_3
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)
prop_5
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[4:5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_5
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_5
#__________________________________________________#
# OUTPUT#
#__________________________________________________#
write.table(current_alloc,"current_alloc.txt")#
#
# plot results#
par(mfrow=c(2,2))#
curve(x^6,-10,10,n=21,type="h",log="y",main="over allocation penalties",col="red",xlab="spare places")#
#
# score evolution#
plot(all_gen_scores,type="l",xlab="gen",ylab="score",log="y",main="scores",col="blue")#
#
# distribution of spare places#
barplot(allocationScore(current_alloc,staff,choice_penalties)$spare,ylab="freq",main="staff load",xlab="students per academic")#
#
# choice distribution#
barplot(allocationScore(current_alloc,staff,choice_penalties)$choices,names.arg=1:length(allocationScore(current_alloc,staff,choice_penalties)$choices),ylab="freq",main="student prefs",xlab="student preferences")#
allocationScore(students,staff,choice_penalties)#
allocationScore(current_alloc,staff,choice_penalties)#
beep(5)#
#
subset(current_alloc,current_alloc$alloc=="SLEC")#
#
prop_1_to_3 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[1:3])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_1_to_3#
#
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_5
current_alloc
# plot results#
par(mfrow=c(2,2))#
curve(x^6,-10,10,n=21,type="h",log="y",main="over allocation penalties",col="red",xlab="spare places")#
#
# score evolution#
plot(all_gen_scores,type="l",xlab="gen",ylab="score",log="y",main="scores",col="blue")#
#
# distribution of spare places#
barplot(allocationScore(current_alloc,staff,choice_penalties)$spare,ylab="freq",main="staff load",xlab="students per academic")#
#
# choice distribution#
barplot(allocationScore(current_alloc,staff,choice_penalties)$choices,names.arg=1:length(allocationScore(current_alloc,staff,choice_penalties)$choices),ylab="freq",main="student prefs",xlab="student preferences")#
allocationScore(students,staff,choice_penalties)#
allocationScore(current_alloc,staff,choice_penalties)#
beep(5)#
#
subset(current_alloc,current_alloc$alloc=="SLEC")#
#
prop_1_to_3 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[1:3])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_1_to_3#
#
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_5
subset(current_alloc,current_alloc$alloc=="RCUT")
subset(current_alloc,current_alloc$alloc=="SLEC")
subset(current_alloc,current_alloc$alloc=="RCUT")
current_alloc
allocationScore(students,staff,choice_penalties)#
allocationScore(current_alloc,staff,choice_penalties)#
beep(5)#
#
subset(current_alloc,current_alloc$alloc=="RCUT")#
subset(current_alloc,current_alloc$alloc=="SLEC")#
#
prop_1_to_3 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[1:3])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_1_to_3#
#
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_5
students
staff
current_alloc
# plot results#
par(mfrow=c(2,2))#
curve(x^6,-10,10,n=21,type="h",log="y",main="over allocation penalties",col="red",xlab="spare places")#
#
# score evolution#
plot(all_gen_scores,type="l",xlab="gen",ylab="score",log="y",main="scores",col="blue")#
#
# distribution of spare places#
barplot(allocationScore(current_alloc,staff,choice_penalties)$spare,ylab="freq",main="staff load",xlab="students per academic")#
#
# choice distribution#
barplot(allocationScore(current_alloc,staff,choice_penalties)$choices,names.arg=1:length(allocationScore(current_alloc,staff,choice_penalties)$choices),ylab="freq",main="student prefs",xlab="student preferences")#
allocationScore(students,staff,choice_penalties)#
allocationScore(current_alloc,staff,choice_penalties)#
beep(5)#
#
subset(current_alloc,current_alloc$alloc=="RCUT")#
subset(current_alloc,current_alloc$alloc=="SLEC")#
#
prop_1_to_3 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[1:3])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_1_to_3#
#
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_5
subset(current_alloc,current_alloc$alloc=="BCUR")
subset(current_alloc,current_alloc$alloc=="SLEC")
subset(current_alloc,current_alloc$alloc=="RCUT")
#__________________________________________________#
# IMPORT DATA#
#__________________________________________________#
# import data#
students <- read.table("~/Dropbox/10 R code/project allocations/Input/student_input.txt",header=TRUE)#
attach(students)#
head(students)#
students$alloc <- as.character(students$alloc)#
str(students)#
students <- students[complete.cases(students),]#
#
staff <- read.table("~/Dropbox/10 R code/project allocations/Input/staff_input.txt",header=TRUE)#
attach(staff)#
head(staff)#
staff$academic <- as.character(staff$academic)#
str(staff)#
#staff$max_students <- rep(5, nrow(staff))#
number_students <- nrow(students)#
number_staff <- nrow(staff)#
number_choices <- 5#
#
# start with random allocation or with everyone assigned to their first choice#
random_choices <- sample(1:number_choices,length(students$alloc),replace=TRUE)#
for(i in 1:length(random_choices))#
{#
	students$alloc[i] <- as.character(students[i, (random_choices[i]+1)])#
}#
dim(students)#
students[,number_choices+2] <- as.character(students[,2])#
allocationScore(students,staff,c(0,1,5,10,100))#
#__________________________________________________#
# OPTIMISE#
#__________________________________________________#
# settings#
choice_penalties <- c(0,1,10,50,100)#
threshold_p_range <- c(0.005,0.1)#
generations <- 500#
mutants <- 100#
current_alloc <- students#
#
all_gen_scores <- rep(NA,generations+1)#
all_gen_scores[1] <- allocationScore(current_alloc,staff,choice_penalties)$score#
#
for(gen in 1:generations)#
{#
all_allocation_scores <- rep(NA,mutants+1)#
all_allocation_scores[1] <- allocationScore(current_alloc,staff,choice_penalties)$score#
#
allocation_list <- list(0)#
allocation_list[[1]] <- data.frame(current_alloc)#
# str(allocation_list)#
#
for(m in 1:mutants)#
{mutant_alloc <- current_alloc#
for(i in 1:nrow(mutant_alloc))#
{#
threshold_p <- runif(1, threshold_p_range[[1]],threshold_p_range[[2]])#
#
random_no <- runif(1,0,1)#
if(random_no<threshold_p)#
{new_choice <- sample(1:number_choices,1)#
mutant_alloc[i,(number_choices+2)] <- as.character(current_alloc[i,(new_choice+1)])}#
}#
all_allocation_scores[m+1] <- allocationScore(mutant_alloc,staff,choice_penalties)$score#
allocation_list[[m+1]] <- data.frame(mutant_alloc)#
#str(all_allocation_scores)#
#str(allocation_list)#
}#
#
# choose best current allocation#
best_alloc <- which(all_allocation_scores == min(all_allocation_scores))[1]#
#
current_alloc <- allocation_list[[best_alloc]]#
colnames(current_alloc) <- c("student_ID",as.character(seq(1: number_choices)),"alloc")#
#
all_gen_scores[gen+1] <- allocationScore(current_alloc,staff,choice_penalties)$score#
if (gen %% 10 ==0) {#
	print(c(gen,min(all_allocation_scores)))#
	par(mfrow=c(1,3))#
# score evolution#
#
plot(all_gen_scores,type="l",xlab="gen",ylab="score",log="y")#
# distribution of spare places#
barplot(allocationScore(current_alloc,staff,choice_penalties)$spare)#
#
# choice distribution#
barplot(allocationScore(current_alloc,staff,choice_penalties)$choices,names.arg=1:length(allocationScore(current_alloc,staff,choice_penalties)$choices))#
}#
}
# plot results#
par(mfrow=c(2,2))#
curve(x^6,-10,10,n=21,type="h",log="y",main="over allocation penalties",col="red",xlab="spare places")#
#
# score evolution#
plot(all_gen_scores,type="l",xlab="gen",ylab="score",log="y",main="scores",col="blue")#
#
# distribution of spare places#
barplot(allocationScore(current_alloc,staff,choice_penalties)$spare,ylab="freq",main="staff load",xlab="students per academic")#
#
# choice distribution#
barplot(allocationScore(current_alloc,staff,choice_penalties)$choices,names.arg=1:length(allocationScore(current_alloc,staff,choice_penalties)$choices),ylab="freq",main="student prefs",xlab="student preferences")#
allocationScore(students,staff,choice_penalties)#
allocationScore(current_alloc,staff,choice_penalties)#
beep(5)#
#
subset(current_alloc,current_alloc$alloc=="RCUT")#
subset(current_alloc,current_alloc$alloc=="SLEC")#
#
prop_1_to_3 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[1:3])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_1_to_3#
#
prop_5 <- sum(allocationScore(current_alloc,staff,choice_penalties)$choices[5])/sum(allocationScore(current_alloc,staff,choice_penalties)$choices)#
prop_5
mutate_route(test_route)
number_of_cities <- 10#
cityID <- seq(1,number_of_cities)#
city_lon <- rnorm(number_of_cities,0,1)#
city_lat <- rnorm(number_of_cities,0,1)#
city_df <- data.frame(cbind(cityID,city_lon, city_lat))#
city_df#
#___________________________________#
my_route <- city_df$cityID#
my_route#
random_route <- sample(1:length(my_route),length(my_route),replace=FALSE)#
#___________________________________#
#
draw_route_loop <- function(city_df,my_route)#
	{#
		cities_coord <- city_df[my_route,2:3] #
		n_cities <- nrow(cities_coord)#
		plot(cities_coord,xlab="x",ylab="y",pch=16,col="red")#
		path_coord <- rbind(cities_coord, cities_coord[1,])#
		for(i in 1:(n_cities))#
			{#
				points(path_coord[i:(i+1),1], path_coord[i:(i+1),2],type="l")#
			}#
#
	}#
#___________________________________#
draw_route_loop(city_df,my_route)#
#
draw_route_loop(city_df, random_route)#
#
#___________________________________#
test_coords <- city_df[,2:3]#
#
coordinate_distance <- function(pt1,pt2)#
{#
	my_dist <- sqrt(abs(pt1[1]-pt2[1])^2 + abs(pt1[2]-pt2[2])^2)#
	return(my_dist)#
}#
#
coordinate_distance(c(1,1),c(2,2))#
coordinate_distance(test_coords[2,],test_coords[3,])#
#
# check if each element in test_seq is less than each element in ref_seq#
# mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)#
#___________________________________#
#
circular_route_distance <- function(city_df,my_route)#
	{#
		cities_coord <- city_df[my_route,2:3] #
		path_coord <- rbind(cities_coord, cities_coord[1,])#
		n_cities <- nrow(path_coord)-1#
		all_distances <- rep(NA,n_cities-1)#
#
		for(i in 1:(n_cities-1))#
			{#
				all_distances[i] <- coordinate_distance(path_coord[i,], path_coord[i+1,])#
			}#
		return(sum(all_distances))#
	}#
#
circular_route_distance(city_df,my_route)#
circular_route_distance(city_df,random_route)#
#___________________________________#
#
my_route#
#
mutate_route <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
new_route[seq(my_pts[1],my_pts[2])] <- new_route[seq(my_pts[2],my_pts[1])]#
return(new_route)#
}#
#
test_route <- sample(0:100,10,replace=FALSE)#
test_route#
mutate_route(test_route)
route_mutate <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
first <- new_route[my_pts[1]]#
second <- new_route[my_pts[2]]#
#
new_route <- my_route#
new_route[my_pts[1]] <- second#
new_route[my_pts[2]] <- first#
return(new_route)#
}#
test_route #
route_mutate(test_route)
route_mutate <- function(my_route)#
{#
my_pts <- sort(sample(1:length(my_route),2,replace=FALSE))#
new_route <- my_route#
first <- new_route[my_pts[1]]#
second <- new_route[my_pts[2]]#
new_route[my_pts[1]] <- second#
new_route[my_pts[2]] <- first#
return(new_route)#
}#
test_route #
route_mutate(test_route)
route_mutate(test_route)
test_route #
route_mutate(test_route)
# apply one vector to another apply function#
test_seq <- 1:3#
ref_seq <- 1:5#
test_seq#
ref_seq#
mapply(function(x,y) x < y, x=test_seq, y=ref_seq)#
sapply(test_seq, function(x) x < 5)#
#
test_seq#
ref_seq#
#
# check if each element in test_seq is less than each element in ref_seq#
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
geoReportHitscores
system.time(mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
# apply one vector to another apply function#
test_seq <- 1:3#
ref_seq <- 1:5#
test_seq#
ref_seq#
mapply(function(x,y) x < y, x=test_seq, y=ref_seq)#
sapply(test_seq, function(x) x < 5)#
#
test_seq#
ref_seq#
#
# check if each element in test_seq is less than each element in ref_seq#
system.time(mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
test_seq
system.time(mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
system.time(mapply(function(x,y), sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
system.time(mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
system.time(mapply(function(x,y) sapply(test_seq, function(x,y) x > y), x=test_seq, y=ref_seq))
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x > y)
system.time(mapply(function(x,y) apply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
system.time(mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
y <- seq(1,100)
sapply(test_seq, function(x) x > y)
y
sapply(test_seq, function(x) x < 5)
sapply(test_seq, function(x) x > ref_seq)
ref_seq
test_seq
sapply(test_seq, function(x) x > y)
mapply(function(x,y) x < y, x=test_seq, y=ref_seq)
# define matrix#
my_mat <- matrix(c(1:30),nrow=3,byrow=TRUE)#
my_mat#
#
# take mean of rows#
apply(my_mat,1,mean)#
# take mean of columns#
apply(my_mat,2,mean)#
# define vector#
my_x <- sample(0:100,100,replace=TRUE)#
my_x#
my_y <- sapply(my_x, function(x) (1.2*x)+rnorm(1,0,20))#
plot(my_x,my_y,pch=16,xlab="x",ylab="y")#
#
# return a list#
# lapply(my_vec, function(x) c(x,sx+rnorm(0,1)))#
# code matrix quickly#
mat1 <- matrix(sample(0:9,25,replace=TRUE),nrow=5)#
mat1#
matrix(sapply(mat1,function(x) x+1),nrow=5)#
scale_value <- 0.001#
matrix(sapply(mat1,function(x) ifelse(is.na(x)==FALSE,0,scale_value)),nrow=5)#
mat3 <- matrix(sample(0:16,replace=TRUE),nrow=4)#
mat4 <- matrix(sample(0:16,replace=TRUE),nrow=4)#
mat3#
mat4#
mat3*mat4#
# apply one vector to another apply function#
test_seq <- 1:3#
ref_seq <- 1:5#
test_seq#
ref_seq#
mapply(function(x,y) x < y, x=test_seq, y=ref_seq)#
sapply(test_seq, function(x) x < 5)#
#
test_seq#
ref_seq#
#
# check if each element in test_seq is less than each element in ref_seq#
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
system.time(mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
?mclapply
library(parallel)
mclapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq))
mclapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) x < y, x=test_seq, y=ref_seq)
mapply(function(x,y) x < y, x=test_seq y=ref_seq)
apply(function(x,y) x < y, x=test_seq, y=ref_seq)
sapply(function(x,y) x < y, x=test_seq, y=ref_seq)
lapply(function(x,y) x < y, x=test_seq, y=ref_seq)
mapply(function(x,y) x < y, x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
apply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
lapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
sapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x > y)
test_seq <- 1:3#
ref_seq <- 1:5#
test_seq#
ref_seq
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
mclapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x < 5)
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
test_seq
ref_seq
test_seq > ref_seq
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x < 5)
sapply(test_seq, function(x) x < c(2,3,4))
sapply(test_seq, function(x) x < c(2,3,4,5))
test_seq
mapply(function(x,y) sapply(test_seq, function(y) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x < c(2,3,4,5))
test_seq
sapply(test_seq, function(x) x < ref_seq)
test_seq
ref_seq
mapply(function(x,y) sapply(test_seq, function(x) x < ref_seq)), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x < ref_seq), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x < ref_seq)
sapply(test_seq, function(x) x > ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x > ref_seq), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(y) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
test_seq#
ref_seq
mapply(function(x,y) sapply(test_seq, function(x) x > y), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x > ref_seq)
test_seq
sapply(test_seq, function(x) x > ref_seq)
mapply(test_seq, function(x) x > ref_seq)
test_seq
ref_seq
mapply(function(x,y) sapply(test_seq, function(x) x > 3), x=test_seq, y=ref_seq)
sapply(test_seq, function(x) x > c(1,2,3))
test_seq
sapply(test_seq, function(x) x < c(1,2,3))
test_seq
mapply(function(x,y) sapply(function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(ref_seq,function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq,function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(ref_seq,function(x) x > y), x=test_seq, y=ref_seq)
mapply(function(x,y) sapply(test_seq,function(x) x > y), x=test_seq, y=ref_seq)
test_seq
ref_seq
?outer
outer(test_seq,ref_seq, <)
outer(test_seq,ref_seq, "<")
?geoRingHitscores
geoRingHitscores
mclapply(function(x) sapply(test_seq, function(x) x > c(1:100)), x=test_seq)
apply(function(x) sapply(test_seq, function(x) x > c(1:100)), x=test_seq)
mclapply(function(x) sapply(test_seq, function(x) x > c(1:100)))
mapply(function(x) sapply(test_seq, function(x) x > c(1:100)))
lapply(my_vec, function(x) c(x,sx+rnorm(0,1)))
my_x <- sample(0:100,100,replace=TRUE)#
my_x#
my_y <- sapply(my_x, function(x) (1.2*x)+rnorm(1,0,20))
my_y
library(parallel)#
my_x <- sample(0:100,100,replace=TRUE)#
my_y <- sapply(my_x, function(x) (1.2*x)+rnorm(1,0,20))
plot(my_x,my_y,pch=16,xlab="x",ylab="y")
my_y <- mclapply(my_x, function(x) (1.2*x)+rnorm(1,0,20))
library(parallel)#
sample_size <- 10000#
my_x <- sample(0:100, sample_size,replace=TRUE)#
#
my_y <- sapply(my_x, function(x) (1.2*x)+rnorm(1,0,20))#
plot(my_x,my_y,pch=16,xlab="x",ylab="y")#
#
my_y <- mclapply(my_x, function(x) (1.2*x)+rnorm(1,0,20))#
plot(my_x,my_y,pch=16,xlab="x",ylab="y")#
#
system.time(sapply(my_x, function(x) (1.2*x)+rnorm(1,0,20)))#
system.time(mclapply(my_x, function(x) (1.2*x)+rnorm(1,0,20)))
?parallel
no_cores <- detectCores() - 1
no_cores
cl <- makeCluster(no_cores)
my_y <- mclapply(my_x, function(x) (1.2*x)+rnorm(1,0,20))#
plot(my_x,my_y,pch=16,xlab="x",ylab="y")#
#
system.time(sapply(my_x, function(x) (1.2*x)+rnorm(1,0,20)))#
system.time(mclapply(my_x, function(x) (1.2*x)+rnorm(1,0,20)))
library(devtools)
install.packages("~/GitHub/Rgeoprofile", repos = NULL, type = "source",force=TRUE)
library(RgeoProfile)
geoPlotMapText
install.packages("~/GitHub/Rgeoprofile", repos = NULL, type = "source",force=TRUE)
library(RgeoProfile)
library(devtools)
install.packages("~/GitHub/Rgeoprofile", repos = NULL, type = "source",force=TRUE)
library(RgeoProfile)
geoPlotMap
geoPlotMapText
library(devtools)
install.packages("~/GitHub/Rgeoprofile", repos = NULL, type = "source",force=TRUE)
library(RgeoProfile)
prob_coallocation
install.packages("~/Desktop/Rgeoprofile-develop", repos = NULL, type = "source")#
#
# load packages#
library(RgeoProfile)
install.packages("~/Desktop/Rgeoprofile-develop", repos = NULL, type = "source")
library(devtools)
install_github("bobverity/Rgeoprofile",ref="develop",force=TRUE)
library(RgeoProfile)
GPshapefile
geoPlotMapText
# running rgeoprofile 2.1.0#
library(devtools)#
#
# install from github or from local copy of package#
# install stable copy of version 2.0.0 from github#
# install_github("bobverity/Rgeoprofile",ref="version2.0.0",force=TRUE)#
# install_github("bobverity/Rgeoprofile",ref="master",force=TRUE)#
# install_github("bobverity/Rgeoprofile",ref="develop",force=TRUE)#
#
# install from local github repository#
# install.packages("~/GitHub/Rgeoprofile", repos = NULL, type = "source",force=TRUE)#
#
# install from downloaded copy on desktop (NB check name and path)#
# install.packages("~/Desktop/Rgeoprofile-develop", repos = NULL, type = "source")#
#
# load packages#
library(RgeoProfile)#
#
# check package#
# setwd("~/GitHub/Rgeoprofile")#
# devtools::check()#
#
# ------------------------------------------------------------------#
# IMPORT DATA AND SET PARAMETERS#
# ------------------------------------------------------------------#
# choose data and sources from options above#
# d <- LondonExample_crimes#
# s <- LondonExample_sources#
#
# load real data#
crime_data <- read.table("~/Dropbox/9 Shared/SLC shared/2 Cases/Cairo/Cairo 2014/MalariaCases139.txt", header = FALSE)#
source_data <- read.table("~/Dropbox/9 Shared/SLC shared/2 Cases/Cairo/Cairo 2014/allvectors.txt", header = FALSE)#
#
d <- geoData(crime_data[,1], crime_data[,2])#
s <- geoDataSource(source_data[,1], source_data[,2])#
# set model and MCMC parameters#
p = geoParams(data = d, sigma_mean = 1.8, sigma_var = 0, sigma_squared_shape = NULL, chains = 5, burnin = 1e3, samples = 1e4, longitude_cells = 200, latitude_cells = 200)#
#
# initial map of data#
# Note that geoPlotMap may occasionally fail to download map. In this case simply run again until it passes#
# Note also that plotting the map may take quite a long time#
# map1 <- geoPlotMap(params = p, data = d, source = s)#
# map1#
#
# plot prior on sigma#
# geoPlotSigma(params = p)#
#
# ------------------------------------------------------------------#
# RUN MCMC#
# ------------------------------------------------------------------#
# run MCMC#
m = geoMCMC(data = d, params = p)#
#
# ------------------------------------------------------------------#
# MAIN DPM OUTPUT#
# ------------------------------------------------------------------#
# plot prior and posterior of sigma#
geoPlotSigma(params = p, mcmc = m)#
abline(v = sigma, col = 2)#
#
# plot profile on map#
map2 <- geoPlotMap(params = p, data = d, source = s, surface = m$geoProfile, mapSource = "google", mapType = "roadmap", breakPercent = seq(0,50,l=11), opacity=0.8, plotContours = TRUE, smoothScale = TRUE, sourceCex = 3, crimeCex = 3)#
map2
load("/Users/stevenlecombermacbookair11/GitHub/Rgeoprofile/data/Cholera.RData")
data(LondonExample_crimes)
LondonExample_crimes
plot(LondonExample_crimes$latitude, LondonExample_crimes$longitude)
plot(LondonExample_crimes$latitude, LondonExample_crimes$longitude, xlab = "lon", ylab = "lat")
document()
setwd("~/GitHub/Rgeoprofile")
devtools::check()
?RgeoProfile
document()
