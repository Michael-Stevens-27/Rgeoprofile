library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # save position of most recently rendered plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	# switch back to old pars#
    par(old.par)#
    #layout(lm)#
    #par(mfg=c(nextPlot[1], , 7,2))#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
	#print(mfg.save)#
    #par(plt = big.par$plt, xpd = FALSE)#
    # move forward from current position#
    #par(mfg = mfg.save, new = FALSE)#
    #par(mfg = mfg.save)#
	print(par()$mfg)#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
layout(matrix(1:9, 3))#
#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], 7,2))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 4)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
lm
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:4, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:4, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:3) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:3) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# set layout from par() if not specified#
	mfrow <- par()$mfrow#
    	lm_full <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
	if (is.null(lm)) {#
		lm <- lm_full#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_full==(thisPlot+1), arr.ind=TRUE)#
	print(mfg)#
	print(thisPlot)#
	print(nextPlot)#
	print(lm_full)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
library(viridis)#
#
foo <- function (..., lm=NULL, add = FALSE, breaks = NULL, nlevel = 64, col = viridis(100), #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
foo <- function (..., lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot()
image.plot
function (..., add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
function (..., add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
foo <- function (..., add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
foo <- function (..., lm = NULL, add = FALSE, breaks = NULL, nlevel = 64, col = NULL, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) #
{#
    old.par <- par(no.readonly = TRUE)#
    if (is.null(col)) {#
        col <- tim.colors(nlevel)#
    }#
    else {#
        nlevel <- length(col)#
    }#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    if (add) {#
        big.plot <- old.par$plt#
    }#
    if (legend.only) {#
        graphics.reset <- TRUE#
    }#
    if (is.null(legend.mar)) {#
        legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
    if (!legend.only) {#
        if (!add) {#
            par(plt = bigplot)#
        }#
        if (!info$poly.grid) {#
            image(..., breaks = breaks, add = add, col = col)#
        }#
        else {#
            poly.image(..., add = add, col = col, midpoint = midpoint, #
                border = border, lwd.poly = lwd)#
        }#
        big.par <- par(no.readonly = TRUE)#
    }#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    if (verbose) {#
        print(breaks)#
        print(midpoints)#
        print(ix)#
        print(iy)#
        print(iz)#
        print(col)#
    }#
    par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    mfg.save <- par()$mfg#
    if (graphics.reset | add) {#
        par(old.par)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
    else {#
        par(big.par)#
        par(plt = big.par$plt, xpd = FALSE)#
        par(mfg = mfg.save, new = FALSE)#
        invisible()#
    }#
}#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(m, lm=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
par(NULL)
header()
library(viridis)#
#
foo <- function (..., lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
m <- matrix(rnorm(100),10)#
#r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#foo(m)#
foo(r, lm=lm)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
r
?image
image(m)
m <- matrix(rnorm(100^2),100)
win()
image(m)
image(m, useRaster=TRUE)
?image
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)
image(m, useRaster=TRUE)
image(m)
plot(5)
image(m)
plot(5)
image(m, useRaster=TRUE)
m <- matrix(rnorm(gridSize^2), gridSize)
image(m, useRaster=TRUE)
image(m)
image(m, useRaster=TRUE)
layout
library(viridis)#
#
#quickRaster <- function (z, lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (z, lm = NULL, ...) {#
    	# get layout matrix if simple increasing grid of values#
	mfrow <- par()$mfrow#
    	lm_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(lm)) {#
		lm <- lm_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    if (verbose) {#
        print(info)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)
quickRaster(m)
image
? imagePlotInfo
library(viridis)#
#
quickRaster <- function (..., lm = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- lm[mfg[1], mfg[2]]#
	nextPlot <- which(lm_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,7), c(2,2,3,3,3,5,6))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:6) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
quickRaster(m, layout_mat=lm)
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 200#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
?image.plot
quickRaster(m, layout_mat=lm, breaks=c(0,1))
quickRaster(m, layout_mat=lm, breaks=c(0,1), col=1:2)
quickRaster(m, layout_mat=lm, breaks=c(0,1), col=1)
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=c(0,1), col=1)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
seq(-1,1)
library(viridis)#
#
quickRaster <- function (..., layout_mat = NULL, col = viridis(100), add = FALSE, breaks = NULL, nlevel = 64, #
    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
    border = NA, lwd = 1, verbose = FALSE) {#
#quickRaster <- function (x, layout_mat = NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- viridis::viridis(100)}#
	if (! "xlab" %in% argNames) {args$xlab <- "iteration"}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    print(info)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
imagePlotInfo
seq(0,5,n=100)
seq(0,5,l=100)
imageplot.setup
?imageplot.setup
?image.plot
image.plot
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    if (is.null(breaks)) {#
    		midpoints <- seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), l=nlevel)#
    		delta <- (midpoints[2] - midpoints[1])/2#
    		breaks <- c(midpoints[1] - delta, midpoints + delta)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	print(temp)#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    if (is.null(breaks)) {#
    		midpoints <- seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), l=nlevel)#
    		delta <- (midpoints[2] - midpoints[1])/2#
    		breaks <- c(midpoints[1] - delta, midpoints + delta)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
#par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    if (is.null(breaks)) {#
    		midpoints <- seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), l=nlevel)#
    		delta <- (midpoints[2] - midpoints[1])/2#
    		breaks <- c(midpoints[1] - delta, midpoints + delta)#
    }#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(x, breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (x, col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, ...) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(x, breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(x, breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
	# switch back to old pars#
    #par(old.par)#
    #par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1),  bigplot=NULL, smallplot=NULL, axis.args=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
library(viridis)#
#
#quickRaster <- function (..., layout_mat = NULL, col = viridis::viridis(100), breaks = NULL, add = FALSE, nlevel = 64, #
#    horizontal = FALSE, legend.shrink = 0.9, legend.width = 1.2, #
#    legend.mar = ifelse(horizontal, 3.1, 5.1), legend.lab = NULL, #
#    legend.line = 2, graphics.reset = FALSE, bigplot = NULL, #
#    smallplot = NULL, legend.only = FALSE, lab.breaks = NULL, #
#    axis.args = NULL, legend.args = NULL, legend.cex = 1, midpoint = FALSE, #
#    border = NA, lwd = 1, verbose = FALSE) {#
quickRaster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
quickRaster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster
faster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
#lm <- matrix(1:4, 2)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:4, 2)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=viridis::viridis(100), breaks=NULL, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# get input arguments#
 	args <- list(...)#
	argNames <- names(args)#
	# set defaults on undefined arguments#
	if (! "col" %in% argNames) {args$col <- NULL}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1), col=1:2)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(m, layout_mat=lm, breaks=seq(-1,1))
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
imagePlotInfo
?imagePlotInfo
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)+1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)+1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    	print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)+1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    	print(length(breaks))#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    	print(length(breaks))#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
#lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1,0.5))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, breaks=seq(-1,1,0.5))#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(m, layout_mat=lm)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	print(nlevel)#
    	print(length(breaks))#
    print(length(col))#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(lm), ncol(lm)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(m, layout_mat=lm, horizontal=TRUE)
win(2,2)
faster(m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}
faster(m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}
faster(m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}
faster(m, layout_mat=lm, horizontal=TRUE)
faster(m, layout_mat=NULL, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=NULL, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, add=FALSE, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = add, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = add, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
?image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    		legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    #axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
    #        mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
    #        axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    #axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
    #        mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
    #        axis.args)#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    do.call(mtext, legend.args)#
    # get position of next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    print( c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)) )#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image.plot
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=TRUE)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=TRUE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}#
#
#raster::plot(r)    # after the raster tiling switches to horizontal#
#image(m)#
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=FALSE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
	print(par()$mfg)#
}
image
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)
plot(f1)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
plot(f1)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- exp(-z/(2*N))#
lines(f2)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2)
N <- 5#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2, col=2)
N <- 100#
#
z <- 0:50#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2, col=2)
N <- 100#
#
z <- 0:500#
#
f1 <- (1-1/(2*N))^z * 1/(2*N)#
#
win()#
plot(f1)#
#
f2 <- 1/(2*N) * exp(-z/(2*N))#
lines(f2, col=2)
faster <- function (..., col=NULL, breaks=NULL, nlevel=64, layout_mat=NULL, horizontal=FALSE, legend.shrink=0.9, legend.width=1.2, legend.mar=ifelse(horizontal, 3.1, 5.1), legend.lab=NULL, legend.line=2,  bigplot=NULL, smallplot=NULL, lab.breaks=NULL, axis.args=NULL, legend.args=NULL, legend.cex=1) {#
    	# set defaults#
    	if (!is.null(breaks)) {#
    		nlevel <- length(breaks)-1#
    	}#
    	if (is.null(col)) {#
    		col <- viridis::viridis(nlevel)#
    	} else {#
    		nlevel <- length(col)#
    	}#
    	if (is.null(legend.mar)) {#
    	legend.mar <- ifelse(horizontal, 3.1, 5.1)#
    }#
    	# get layout matrix assuming simple increasing grid of values#
	mfrow <- par()$mfrow#
    	layout_simple <- matrix(1:(mfrow[1]*mfrow[2]), mfrow[1], mfrow[2], byrow=TRUE)#
    # set layout to simple grid if not specified#
	if (is.null(layout_mat)) {#
		layout_mat <- layout_simple#
	}#
    # set breaks evenly over data range if not specified#
    nlevel <- length(col)#
    info <- imagePlotInfo(..., breaks = breaks, nlevel = nlevel)#
    breaks <- info$breaks#
    # get plotting limits#
    temp <- imageplot.setup(add = FALSE, legend.shrink = legend.shrink, #
        legend.width = legend.width, legend.mar = legend.mar, #
        horizontal = horizontal, bigplot = bigplot, smallplot = smallplot)#
    smallplot <- temp$smallplot#
    bigplot <- temp$bigplot#
	# main image plot#
    old.par <- par(plt = bigplot)#
    image(..., breaks = breaks, add = FALSE, col = col)#
    # check legend will fit#
    if ((smallplot[2] < smallplot[1]) | (smallplot[4] < smallplot[3])) {#
        par(old.par)#
        stop("plot region too small to add legend\n")#
    }#
	# make colour scale#
    ix <- 1:2#
    iy <- breaks#
    nBreaks <- length(breaks)#
    midpoints <- (breaks[1:(nBreaks - 1)] + breaks[2:nBreaks])/2#
    iz <- matrix(midpoints, nrow = 1, ncol = length(midpoints))#
    # add colour scale#
    par(old.par)#
    old.par <- par(new = TRUE, pty = "m", plt = smallplot, err = -1)#
    if (!horizontal) {#
        image(ix, iy, iz, xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    else {#
        image(iy, ix, t(iz), xaxt = "n", yaxt = "n", xlab = "", #
            ylab = "", col = col, breaks = breaks)#
    }#
    # add numbers and box to scale#
    if (!is.null(lab.breaks)) {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2), #
            at = breaks, labels = lab.breaks), axis.args)#
    }#
    else {#
        axis.args <- c(list(side = ifelse(horizontal, 1, 4), #
            mgp = c(3, 1, 0), las = ifelse(horizontal, 0, 2)), #
            axis.args)#
    }#
    do.call("axis", axis.args)#
    box()#
	# add legend to scale#
    if (!is.null(legend.lab)) {#
        legend.args <- list(text = legend.lab, side = ifelse(horizontal, #
            1, 4), line = legend.line, cex = legend.cex)#
    }#
    if (!is.null(legend.args)) {#
        do.call(mtext, legend.args)#
    }#
    # get position of current and next plot#
	mfg <- par()$mfg#
	thisPlot <- layout_mat[mfg[1], mfg[2]]#
	nextPlot <- which(layout_simple==(thisPlot+1), arr.ind=TRUE)[1,]#
	# switch back to old pars#
    par(old.par)#
    # set position of next plot#
    par(mfg=c(nextPlot[1], nextPlot[2], nrow(layout_mat), ncol(layout_mat)))#
}#
#
# ------------------------------------------------------------------#
#
# create a raster#
gridSize <- 50#
m <- matrix(rnorm(gridSize^2), gridSize)#
r <- raster::raster(m)#
#
# tile plots vertically#
lm <- matrix(1:9, 3)#
lm <- cbind(c(1,1,3,3,3,4,4), c(2,2,3,3,3,5,5))#
layout(lm)#
#
# bunch of plots#
for (i in 1:2) {#
	plot(0,0,type="n")#
	text(0,0,i)#
}#
#
faster(1:gridSize, 1:gridSize, m, layout_mat=lm, horizontal=FALSE)#
#
for (i in 3:4) {#
	plot(0,0,type="n")#
	text(0,0,i)#
}
image.plot
myFunctions()
pieCharts
pieCharts(0,0)
win()
plot(0,0)
pieCharts(0,0, c(0.5,0.2,0.3))
pieCharts(0,0, c(5,0.2,0.3))
pieCharts(0,0, c(50,0.2,0.3))
pieCharts(0,0, c(0.5))
?pieCharts
pieCharts(0,0, 1:10)
pieCharts
pieCharts(0,0, list(1:4))
pieCharts(0,0, list(1:4), col=bobFireIce())
pieCharts(0,0, list(1:4), seg_col=bobFireIce())
pieCharts(0,0, list(1:4), seg_col=bobFireIce(10))
pieCharts(0,0, list(1:4), seg_col=bobFireIce(4))
myFunctions()
library(bobFunctions)
myFunctions()
headEr()
header*
()
header()
install_github('bobverity/bobFunctions')
library(devTools)
library(devtools)
install_github('bobverity/bobFunctions')
library(bobFunctions)
myFunctions()
?faster
faster
# ------------------------------------------------------------------#
#
library(bobFunctions)#
#
groupProb <- function(group0, group, K, p) {#
	ng <- 2#
	q <- c(1/K, 1-1/K)#
	pp <- 0#
	for (i in 2:n) {#
		if (group[i]==group0[i]) {#
			pp <- pp + log( 1-p + p*q[group[i]] )#
		} else {#
			pp <- pp + log(p*q[group[i]])#
		}#
		if (group[i]==ng) {#
			q[ng] <- 1/K#
			q[ng+1] <- 1-ng/K#
			ng <- ng+1#
		}#
	}#
	return(pp)#
}#
drawGroup <- function(group0, K, p) {#
	n <- length(group0)#
	group <- group0#
	ng <- 2#
	q <- c(1,K-1)#
	for (i in 2:n) {#
		if (runif(1)<p) {#
			group[i] <- sample(ng, 1, prob=q)#
		}#
		if (group[i]==ng) {#
			q[ng] <- 1#
			q[ng+1] <- K-ng#
			ng <- ng+1#
		}#
	}#
	return(group)#
}#
#
drawGroup_mix <- function(group, K, p) {#
	i <- sample(nrow(group), 1)#
	return( drawGroup(group[i,], K, p) )#
}#
#
image(group)
p <- 0.1#
g2 <- matrix(0,10,ncol(group))#
for (i in 1:nrow(group)) {#
	g2[i,] <- drawGroup_mix(group, 3, p)#
}#
#
groupProb(group[1,], g2, 3, p)#
# ------------------------------------------------------------------#
#
#set.seed(1)#
#
# simulate data#
n <- 20#
mu_true <- c(-3,3)#
K_true <- length(mu_true)#
sigma <- 1#
#
group_true <- sort(sample(1:K_true, n, replace=TRUE))#
x <- rnorm(n, mean=mu_true[group_true], sd=sigma)#
#
# define inference and MCMC parameters#
burnin <- 1e1#
samples <- 1e3#
rungs <- 1#
beta_vec <- 1#
reps <- burnin+samples#
K <- 3#
tau <- 10#
#
MCmethod <- 1#
#
# ------------------------------------------------------------------#
# generate scaffold groupings#
#
# generate by MCMC#
scaf_reps <- 1e1#
scaf_iterations <- 1e1#
#
group <- matrix(NA, scaf_reps, n)#
mu <- rep(NA,K)#
for (rep in 1:scaf_reps) {#
	group[rep,] <- sample(1:K, n, replace=TRUE)#
	for (it in 1:scaf_iterations) {#
		beta <- 1#
		# update mu#
	    for (i in 1:K) {#
	      ni <- sum(group[rep,]==i)#
	      post_var <- 1/(beta*ni/sigma^2 + 1/tau^2)#
	      post_mean <- beta*sum(x[group[rep,]==i])/sigma^2 * post_var#
	      mu[i] <- rnorm(1, post_mean, sqrt(post_var))#
	    }#
	    # update group#
	    z <- mapply(dnorm, mean=mu, MoreArgs=list(x=x, sd=sigma))#
	    group[rep,] <- apply(z, 1, function(x){sample(1:K, 1, prob=beta*x)})#
	}#
}#
#
# simplify#
for (i in 1:scaf_reps) {#
	group[i,] <- match(group[i,], unique(group[i,]))#
}
image(group)
p <- 0.1#
g2 <- matrix(0,10,ncol(group))#
for (i in 1:nrow(group)) {#
	g2[i,] <- drawGroup_mix(group, 3, p)#
}
image(g2)
11000/1800
3000/23
n <- 5#
m <- 10#
#
p <- matrix(sample(4, n*m, repeat=TRUE), n)#
#
image(p)
p
sample(4, n*m, repeat=TRUE)
p <- matrix(sample(4, n*m, replace=TRUE), n)
n <- 5#
m <- 10#
#
p <- matrix(sample(4, n*m, replace=TRUE), n)#
#
image(p)
n <- 5#
m <- 10#
#
p <- matrix(sample(4, n*m, replace=TRUE), n)#
#
image(t(p))
n <- 20#
m <- 10#
#
p <- matrix(sample(4, n*m, replace=TRUE), n)#
#
image(t(p))
n <- 10#
m <- 30#
#
p <- matrix(sample(4, n*m, replace=TRUE), n)#
#
image(t(p))
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
image(t(p))
p
q <- sample(m,m,2)
q <- sample(m,m/2)
q
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[]i]]#
}#
#
image(t(p))
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]#
}#
#
image(t(p))
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p))
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=1:4)
library(bobFunctions)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=1:4)
myFunctions()
colPlot(bobNiceCols())
library(bobFunctions)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobNiceCols(4))
library(bobFunctions)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobNiceCols()[1:4])
image(t(p), col=bobRainbow()[1:4])
library(bobFunctions)#
#
n <- 5#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:4])
library(bobFunctions)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:4])
library(bobFunctions)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:4])
library(bobFunctions)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:4])
set.seed(1)
library(bobFunctions)#
set.seed(1)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:4])
library(bobFunctions)#
set.seed(2)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:4])
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:4])
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=bobRainbow()[1:2])
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c(1,2))
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c(1,0))
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c(2,0))
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c(2,0), ann=FALSE)
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c(2,0), ann=FALSE, axes=FALSE)
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c(2,0), ann=FALSE, axes=FALSE)#
box()
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(0.5)), ann=FALSE, axes=FALSE)#
box()
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(0.9)), ann=FALSE, axes=FALSE)#
box()
text(1:5, 1:5)
text(1:5, 1:5, 1:5)
text(seq(0,1,l=5), 1:5, 1:5)
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(0.9)), ann=FALSE, axes=FALSE)#
box()#
text(seq(0,1,l=5), 1:5, 1:5)
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(0.9)), ann=FALSE, axes=FALSE)#
box()#
text(seq(0,1,l=5), rep(1,5), 1:5)
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(0.9)), ann=FALSE, axes=FALSE)#
box()#
text(seq(0,1,l=m), rep(1,5), 1:5)
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(0.9)), ann=FALSE, axes=FALSE)#
box()#
text(seq(0,1,l=m), rep(1,5), sample(c("A", "C", "T", "G"), m, replace=TRUE))
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(0.9)), ann=FALSE, axes=FALSE)#
#box()#
text(seq(0,1,l=m), rep(1,5), sample(c("A", "C", "T", "G"), m, replace=TRUE))
library(bobFunctions)#
set.seed(3)#
#
n <- 10#
m <- 30#
#
p <- matrix(sample(2, n*m, replace=TRUE), n)#
#
z <- 10:20#
for (i in 1:n) {#
	if (i<(n/2)) {#
		p[i,z] <- p[1,z]#
	} else {#
		p[i,z] <- p[n,z]#
	}#
}#
#
q <- sample(m,m/2)#
for (i in 1:length(q)) {#
	#p[,q[i]] <- c(3,4)[p[,q[i]]]#
}#
#
image(t(p), col=c("red", grey(1)), ann=FALSE, axes=FALSE)#
#box()#
text(seq(0,1,l=m), rep(1,5), sample(c("A", "C", "T", "G"), m, replace=TRUE))
m <- matrix(rnorm(100),10,10)#
#
image(m)
image(raster(m))
library(raster)
image(raster(m))
image(m)
image(raster(m))
plot(raster(m))
setwd("~/Dropbox/Bob/Work/My Programs/Geoprofiling/RgeoProfile/data")#
#
WaterPumps <- read.table("WaterPumps.txt", header=TRUE)
WaterPumps
setwd("~/Dropbox/Bob/Work/My Programs/Geoprofiling/RgeoProfile/data")#
#
WaterPumps <- read.table("WaterPumps.txt", header=TRUE)#
#
names(WaterPumps) <- c("longitude", "latitude")#
WaterPumps <- as.list(WaterPumps)#
#
save(WaterPumps, file="WaterPumps.RData")
library(bobFunctions)
header()
header("deploy_RgeoProfile")
