---
title: "Introduction to using R - Part 2"
author: "Michael Stevens"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to using R - Part 2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction 

In this tutorial we will move on to the next steps of using R, this will include:

* Using functions
* Classes
* vectors, matrices
* More on functions

## Using functions

In R, **functions** are tools that we use that take some input and produce an output. The standard format for a function is the following:

```{r}
my_function <- function( arguments ) { body }
```    

The term `function` here refers to the fact we are writing a function. This function has `arguments`. We refer to `arguments` as the input for the function. The `body` of the function contains all the code that manipulates the input arguments to produce the output. Finally, we assign this function to an object so we can use it later. Notice that the arguments are contained within parentheses `()`, but the body of the function is contained within curly brackets `{}`. Although we have names this function "my_function", it is worth remembering that the name of this object could be anything we choose. Let's see an example. Let's write a function that adds any two numbers together.  

```{r}
# write a function that adds two numbers together and returns the sum
add <- function(x, y){
  z <- x + y 
  return(z)
}
```    

Let's go through this line by line. In the first line we assign our function to the object name `add`, we then open up `function` with a left parenthesis, type out our arguments (two numbers, `x` and `y`) then close the parentheses. We then open up the body of the function by opening the curly brackets. we then begin the body on the next line. The next line assigns the sum of `x` and `y` to a new object `z`. Finally, we get the function to produce the value of `z` to us using the `return()` function. We then close the curly brackets. Let's try using our function:

```{r}
# add one and two, again
add(1, 2)
```    

Notice that the R environment now has a function in its memory. 

\      
![](https://github.com/Michael-Stevens-27/Rgeoprofile/raw/workshop/docs/articles/images/function_env.png)
\  

## Classes

In the previous tutorial we played around with some basic arithmetic and logical statements such as the below:

```{r}
# assign x the value 7
x <- 7

# assign y the outcome of the logical statement x > 4
y <- x > 4
y
``` 

In these examples the **class** of `x` is reffered to as **numeric** and the class of `y` is reffered to as **logical**. This is of course, since `x` represents the numerical value `5` and `y`, the logical value `TRUE`. There is another important class we are yet to use, that is, the **character** class. The class of an object is character if it has been assigned using double or single quotation marks (`" "` or `' '`).

```{r}
# create a character object
my_name <- "john smith"
my_address <- '123 Fake Street'
```

We can view an object's class using the `class()` function. For this function, we input an object and the output will print the object's class. 

```{r}
# create a numerical, logical and character objects
x <- 27
class(x)

y <- 15 != 12
class(y)

z <- "hello"
class(z)
```

## Vectors and Matrices

So far, we have assigned each object a single value that's either numeric, logical or character. Vectors and matrices are a couple of the main data types in R that are used to collect and manipulate multiple R objects at the same time. To create a **vector** we use an important R function denoted by `c()`. Here, `c()` can be thought of as short for "concatonate", "collect" or "combine". Using `c()` we can collect objects of the same type together to create a vector.

```{r}
# create a vector
my_vector <- c(7, 2, 5, 1, 6, 19)
my_vector
```

Notice that `my_vector` has appeared in the top right in R studio. 

\      
![](https://github.com/Michael-Stevens-27/Rgeoprofile/raw/workshop/docs/articles/images/my_vec.png)
\  

We can see that now gives us more information than simply the values in this vector. In addition to this, R stores the class of the vector "num" short for "numerical" and the **index** of the vector runs from one to six, denoted by "[1:6]". Indexing in R starts at 1 and ends at the length of the vector. If we want to access a particular value or set of values from our vector, then we need to provide R with the index of the values we want. We do this using square brakets `[]`.

```{r}
# access the 3rd value in our vector
my_vector[3]

# access the 2nd and 5th value in our vector
my_vector[c(2,5)]
```

Note that our vector is a collection of values that share the same class. It's not possible to have a vector that contains a numeric, lofical and character value. Let's see what ahppens if we try. 

```{r}
# try to create a vector with a numeric, logical and character value
my_other_vector <- c(1, 3, "hello", TRUE) 
my_other_vector
```

As we can see R has forced all other values besides "hello" into character form. 

A **matrix** is a collection of values that spans many rows and columns. We can constuct a matrix using the `matrix()` function. In order to build a matrix, the function requires a vector of values, the number of rows and the number of columns. Let's use `my_vector` to populate a matrix with 3 rows and 2 columns. 

```{r}
# create a matrix using my_vector
my_matrix <- matrix(data = my_vector, nrow = 3, ncol = 2, byrow = FALSE)

my_matrix
```

As we can see we provide the matrix function with `data`, the number of rows and columns (`nrow` and `ncol`) and if we should fill the matrix by row if `byrow = TRUE` or by column, if `byrow = FALSE`. To access a particular value in a matrix, we once again use the square brackets with a refference to the corresponding row and column of that value.  

```{r}
# get the 2nd value from the first column of the matrix
my_matrix[2, 1]

# access the entire first row
my_matrix[1, ]

# access the entire second column 
my_matrix[, 2]

# access the 2nd AND third values of the second row
my_matrix[c(2,3), 2]
```

Generally, the code `my_matrix[i, j]` will return the value in the ith row and the jth column of the matrix.  

## More on functions

Now we know a bit more about different data types in R, it's time to talk a little bit more about functions. Recall the general structure of a function is:

```{r}
my_function <- function( arguments ) { body }
```

Each function comes with its own arguments that we need to supply it with to make it work properly. We just saw the arguments needed to run the matrix function, but what happens if we don't provide the matrix function with all of the arguments? 

```{r}
# create a matrix using my_vector
my_new_matrix <- matrix(data = my_vector)

my_new_matrix
```

As we can see the code still works but it returns a different number of rows and columns. Why is this? Why doesn't the code break since we don't provide all the extra information? This will be due to the function's **default arguments**. Essentially, if we don't provide information to a function, such as the matrix's number of rows, the function will have a default that it will assume you wanted! We can see a function's default arguments using the `args()` function.

```{r}
# show me the arguments of the matrix function
args(matrix)
```

Here we can see all the arguments of the `matrix()` function. The first is normally the most important for the function to work properly. As we can see the `data` argument's default is `NA`. This stands for "not available". This means we must provide the function with some data or the function will return an error. We can also see that the `matrix()` function has default values for the `nrow`, `ncol` and `byrow` arguments. The `args()` function is an incredibly useful, tool in understanding what a function needs. We can even see that `args(matrix)` tells us about an argument we didn't know was used in the matrix function `dimnames`. As with `dimnames`, any argument that is equal to `NULL` is an argument that we can choose to use (in this case to set the names of the rows and columns) but it is not a necessity for the function to run. As we saw at the beginning of the first tutorial, we can learn more about how a function works by placing a single question mark before a function name.  

```{r, eval = FALSE}
# help on the matrix function
?matrix
```

With this you should notice that the "help" tab of the bottom right panel should open up with the documentation related to the matrix function. 

\      
![](https://github.com/Michael-Stevens-27/Rgeoprofile/raw/workshop/docs/articles/images/matrix_help.png)
\  

It may be cumbersome to write out all of the arguments in a function, so it is possible simply to write the value of the argument in the function leading to the same result:

```{r}
# create a matrix using my_vector
my_matrix <- matrix(my_vector, 3, 2, FALSE)

my_matrix
```

As we can see this leads to the same result and is much neater. It is also possible to mix up the order of the arguments in a function, BUT you must include the argument names inside the function if you are to do this. 


```{r}
# create a matrix using my_vector
my_matrix <- matrix(nrow = 3, ncol = 2, data = my_vector, byrow = FALSE)

my_matrix
```

Despite mixing up the arguments, this code produced the same matrix. The matrix function only has a handful of arguments, but other R functions may have considerably more. That's why it is recommended to write each argument on a new line of code.  

```{r, eval = TRUE}
# create a matrix using my_vector
my_matrix <- matrix(nrow = 3, 
                    ncol = 2, 
                    data = my_vector, 
                    byrow = FALSE)

my_matrix
```

This code is neater and it becomes much easier to scan through which of the function's arguments we are using. Notice in the console that at the beginning of each line we now see a `+` symbol, instead of a `>` symbol. This `+` symbol indicates that we have started executing some of our code, but we're not finished. This `+` symbol is R's way of telling us that we've begun running some code, and R wants us to finish it off. In this case we started running the matrix function on one line and we finished running it three lines later.   

\      
![](https://github.com/Michael-Stevens-27/Rgeoprofile/raw/workshop/docs/articles/images/plus.png)
\  

There are a huge number of other functions that R has ready to use. Many of which were built to speed up operations on vectors and matrices. Imagine you have a numerical vector of length 15, and you wanted to find the sum of these numbers. It would be a lot of effort to type the summation out by hand. Instead we can use the `sum()` function. 

```{r, eval = TRUE}
# create a vector with 15 numerical values
my_vector <- c(1, 3, 6, 54, 3, 2, 3, 5, 5, 2, 1, 2, 34, 5, 45, 126)

# add the numbers together
sum(my_vector)
```

A few other useful functions are:

```{r, eval = TRUE}
# find the average
mean(my_vector)

# find the variance
var(my_vector)

# find the maximum value
max(my_vector)

# find the minimum
min(my_vector)
```

## More examples

Here are a few more examples that combine many of the principles in this tutorial, whilst throwing in some additional basic function. 


```{r, eval = TRUE}
# create a vector
my_vector <- c(1, 5, 6, 8, 3, 4, 5, 0, 8, 1, 2, 3, 5, 6, 5, 34, 24, 56, 5, 4, 3)

# check the length of this vector
length(my_vector)

# double every value in this vector 
2*my_vector

# find the minimum of this vector
min(my_vector)

# find the index of the minimum value
which.min(my_vector)

# check with a logical statement
my_vector[8] == 0

# find the 7th, 10th and 12th values in this vector
my_vector[c(7,10,12)]

# tell me which values are greater than 10
my_vector > 10

# now return the values greater than ten with a logical statment for the index
my_vector[my_vector > 10]

# create a matrix from this vector with 3 rows and 7 columns, fill it byrow
my_matrix <- matrix(data = my_vector,
                    nrow = 3,
                    ncol = 7,
                    byrow = TRUE)

# return the 1st value of the 3rd row                    
my_matrix[3, 1]

# find the mean of a the values in the matrix
mean(my_matrix)

# find the square root of each value in the matrix
sqrt(my_matrix)

# or
my_matrix^0.5
```

Once again, have a go coming up with your own examples and mess around with the ones above.  
